# 기본 반환값을 적절하게 사용하라
<br/>

합리적인 기본값은 사용자 친화적인 소프트웨어를 만들기 위한 좋은 방법이다.
워드프로세스 프로그램을 열 때마다 단어를 입력하기 전에 항상 원하는 글꼴, 텍스트 크기, 텍스트 색, 배경색, 줄 간겨겨 및 줄 높이를 정확하게 선택해야 한다고 상상해보라.
그 소프트웨어는 사용하기에 매우 짜증 날 것이고, 아마 다른 워드프로세스로 바꿀 것이다.

실제로 대부분의 워드프로세서는 일련의 적절한 기본값을 제공한다. 프로그램을 열면 글꼴, 텍스트 크기, 배경색 등이 기본 선택 항목으로 설정되어 있다.
즉, 입력을 즉시 시작할 수 있으며 원하는 경우에만 설정을 변경할 수 있다.

사용자가 직접 사용하지 않는 소프트웨어에서도 기본값은 여전히 유용하다.
어떤 클래스가 10개의 매개변수를 사용하여 생성되는데, 이 값을 모두 제공하지 않아도 된다면 호출하는 쪽의 작업이 쉬워진다.
제공되지 않는 매개변수에 대해서는 클래스가 기본값을 제공할 수 있다.

기본값을 제공하려면 종종 다음과 같은 두 가지 가정이 필요하다.
- 어떤 기본값이 합리적인지
- 더 상위 계층의 코드는 기본값을 받든지 명시적으로 설정된 값을 받든지 상관하지 않는다.

앞서 살펴본 것처럼 가정의 비용과 이점을 고려해야 한다. 이런 가정을 상위 수준의 코드에서 하는 것이 낮은 층위에서 하는 것보다 비용이 적게 드는 경향이 있다.
상위 수준의 코드는 특정 사용 사례에 더 밀접하게 결합하므로 코드의 모든 용도에 맞는 기본값을 선택하기가 더 쉽다.
반면에 낮은 수준의 코드는 보다 근본적인 하위 문제를 해결하여 여러 사용 사례에 더 광범위하게 재사용되는 경향이 있다.
따라서 낮은 층위에서는 모든 용도에 적합한 기본값을 선택하기가 훨씬 더 어렵다.
<br/>
<br/>
## 1. 낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다
워드프로세서를 개발하고 있다고 가정해보자. 사용자가 즉시 워드 작업을 시작할 수 있도록 텍스트 스타일링에 대한 기본값을 설정하기로 했다.
사용자가 이러한 사항을 재정의하기를 원할 경우 다시 지정할 수 있다. 예제 9.12는 폰트를 선택할 때 이것을 구현하는 한 가지 방법을 보여준다.
UserDocumentSettings 클래스는 특정 문서에 대한 사용자의 환경설정을 저장하며, 그중에 한 가지가 사용할 글꼴이다.
글꼴을 지정하지 않은 경우 getPreferredFont() 함수는 기본값인 Font.ARIAL을 반환한다.

이렇게 하면 방금 언급한 요구 사항은 충족되지만, 기본 글꼴로 Arial을 원하지 않는 경우에 UserDocumentSettings 클래스를 다시 사용하고자 하는 경우 어려움을 겪을 수 있다.
사용자가 특별히 Arial을 선택한 것인지 아니면 선호하는 폰트를 설정하지 않아 기본값이 반환된 것인지 구분하는 것이 불가능하다.

#### [예제 9.12] 기본값 반환
```java
class UserDocumentSettings {
  private final Font? font;
  ...

  Font getPrefferedFont() {
    if (font != null) {
      return font;
    }
    return Font.ARIAL;  // 사용자가 선호하는 폰트가 지정되어 있지 않은 경우 기본값인 Font.ARIAL을 반환한다.
  }
}
```
이 방식은 적응성에도 해가 될 수 있는데, 기본값과 관련된 요구 사항이 변경되는 경우 문제가 될 수 있다.
한 가지 예로 워드프로세서를 큰 회사에 판매하기 시작했는데, 이 회사가 기본 글꼴을 전사적으로 지정할 수 있기를 원한다고 하자.
이 기능은 구현하기 어려운데 UserDomentSettings 클래스에 대해 사용자가 제공한 환경설정이 없고, 따라서 조직 전체의 기본값이 적용되어야 하는 경우를 구분할 수 없기 때문이다.

기본 반환값을 UserDocumentSettings 클래스와 묶어 놓은 것은 모든 상위 계층에 대해 Arial이 적합한 기본 글꼴이라고 가정한 것이 된다.
처음에는 괜찮겠지만 다른 개발자가 코드를 재사용하거나 요구 사항이 변경되면 이러한 가정은 쉽게 문제가 될 수 있다.
다음 그림은 이와 같은 가정이 상위 계층의 코드에 어떻게 영향을 미치는지 보여준다. 기본값을 정의하는 코드의 계층이 낮을수록 그 가정이 적용되는 상위 계층은 더 많아진다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/7a43afa0-3ece-4a61-87f2-bd7b3380f32e" width="600" height="350"/><br/>
- 가정은 상위 계층에 영향을 미친다. 낮은 층위의 코드에서 기본값을 반환하면 높은 층위의 코드에 영향을 미치는 가정을 하는 것이 된다.

2장은 간결한 추상화 계층의 이점을 강조했다. 이를 위한 주요 방법 중 하나는 구별되는 하위 문제를 여러 코드로 분리하는 것이다. UserDocumentSettings 클래스는 이것을 위반한다.
사용자 환경 설정을 검색하는 것과 응용 프로그램에 적합한 기본값을 정의하는 것은 별개의 하위 문제다.
그러나 UserDocumentSettings 클래스는 완전히 분리할 수 없는 방식으로 이들을 함께 묶는다.
이렇게 하면 UserDocumentSettings 클래스를 사용하는 모든 사용자는 기본값 구현을 사용할 수밖에 없다.
이보다 더 나은 방법은 별개의 하위 문제로 분리하고 상위 계층의 코드가 자신에게 적합한 방식으로 기본값을 처리할 수 있도록 하는 것이다.

## 2. 해결책: 상위 수준의 코드에서 기본값을 제공하라
기본값에 대한 결정을 UserDocumentSettings 클래스에서 하지 않도록 하기 위한 가장 간단한 방법은 사용자가 제공한 값이 없을 때 널값을 반환하는 것이다.
다음 예제 코드는 이렇게 변경된 클래스를 보여준다.

#### [예제 9.13] 널값 반환
```java
class UserDocumentSettings {
  private final font? font;
  ...

  Font? getPreferredFont() {  // 사용자가 선호하는 폰트가 없는 경우 널값을 반환한다.
    return font;
  }
}
```
따라서 기본값 제공은 사용자 설정 처리와는 다른 별개의 하위 문제가 된다.
이는 호출하는 쪽에서 원하는 방식으로 이 하위 문제를 해결할 수 있다는 것을 의미하며, 코드의 재사용성을 높여준다.
다음 예제 코드에서 볼 수 있듯이 상위 수준 코드에서 기본값을 제공하는 하위 문제를 해결하기 위한 전용 클래스를 정의할 수 있다.

#### [예제 9.14] 기본값을 캡슐화하기 위한 클래스
```java
class DefaultDocumentSettings {
  ...

  Font getDefaultFont() {
    return Font.ARIAL;
  }
}
```
그다음 기본값과 사용자가 제공한 값 중에서 선택하는 논리를 DocumentSettings 클래스 안에서 정의할 수 있을 것이다. 예제 9.15는 이를 위한 코드를 보여준다.
상위 수준의 코드에서 사용할 설정을 결정할 때 DocumentSettings 클래스는 간결한 추상화 계층을 제공한다.
기본값과 사용자가 제공한 값에 대한 모든 구현 세부 정보를 숨기지만, 동시에 의존성 주입을 사용하여 이러한 구현 세부 정보를 재설정할 수도 있다.
이를 통해 코드의 재사용성과 적응성이 보장된다.

#### [예제 9.15] 설정에 대한 추상화 계층 나열
```java
class DocumentSettings {
  private final UserDocumentSettings userSettings;
  private final DefaultDocumentSettings defaultSettings;

  DocumentSettings(
    // 사용자 설정과 기본값은 의존성 주입으로 제공된다.
      UserDocumentSettings userSettings,
      DefaultDocumentSettings defaultSettings) {
    this.userSettings = userSettings;
    this.defaultSettings = defaultSettings;
  }
  ...

  Font getFont() {
    Font? userFont = userSettings.getPreferredFont();
    if (userFont != null) {
      return userFont;
    }
    return defaultSettings.getFont();
  }
}
```
예제 9.15에서 if 문을 사용하여 널값을 처리하는 것은 약간 투박하다.
C#, 자바스크립트, 스위프트(swift)와 같은 많은 언어에서 **널 병합 연산자**(null coalescing operator)를 사용하여 코드를 훨씬 자연스럽게 만들 수 있다.
대부분의 언어에서는 nullableValue ?? defaultValue와 같이 작성하는데, 이것이 의미하는 바는 nullableValue가 널이 아니면 nullableValue를 반환하고 널이면 defaultValue를
반환한다는 것이다. 예를 들어 C#에서는 getFont() 함수를 다음과 같이 작성할 수 있다.
```java
Font getFont() {
  return userSettings.getPreferredFont() ??  // ??는 널 병합 연산자다.
      defaultSettings.getFont();
}
```

#### [기본 반환값 매개변수]
어떤 기본값을 사용할지에 대한 결정을 호출하는 쪽에서 하도록 하면 코드의 재사용성이 향상되다.
그러나 널 병합 연산자를 지원하지 않는 언어에서 널을 반환하면 호출하는 쪽에서는 널 처리를 위한 반복적인 코드를 작성해야 한다.<br/>
코드의 일부에서 사용하는 한 가지 방법은 기본 반환값 매개변수를 사용하는 것이다. 이에 대한 예로 자바의 Map.getOrDefault() 함수가 있다.
맵에 키값이 있으면 그 값이 반환되지만, 키값이 없는 경우 지정된 기본값이 반환된다. 이 함수에 대한 호출은 다음과 같이 할 수 있다.
```java
String value = map.getOrDefault(key, "default value");
```
이렇게 하면 호출하는 쪽에서는 널값을 처리할 필요 없이 적절한 기본값을 결정할 수 잇다.
<br/>
<br/>
기본값은 코드(및 소프트웨어)를 훨씬 쉽게 사용할 수 있으므로 활용할 가치가 충분하다. 하지만 코드의 어느 부분에서 사용할지 조심하는 것이 바람직하다.
기본값을 반환하면 그 위의 모든 상위 계층에서 해당 값을 사용할 것이라고 가정하기 때문에 코드 재사용과 적응성을 제한할 수 있다.
낮은 층위의 코드에서 기본값을 반환하는 것은 특히 문제가 될 수 있다.
단순히 널을 반환하고 더 높은 층위에서 기본값을 구현하는 것이 나을 수 있는데, 상위 수준에서 상정한 가정은 유효할 가능성이 크다.
