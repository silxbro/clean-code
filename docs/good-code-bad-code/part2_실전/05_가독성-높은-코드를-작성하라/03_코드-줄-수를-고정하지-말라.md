# 코드 줄 수를 고정하지 말라
<br/>

일반적으로 코드베이스의 코드 줄 수는 적을수록 좋다.
코드는 일반적으로 어느 정도의 지속적인 유지보수를 필요로 하며 코드의 줄이 많다는 것은 코드가 지나치게 복잡하거나, 기존 코드를 재사용하지 않고 있다는 신호일 수 있다.
또한, 코드 줄이 많으면 읽어야 할 코드의 양이 늘어나기 때문에 개발자의 인지 부하가 증가할 수 있다.

어떤 개발자들은 때로 이것을 극단적으로 받아들여 코드의 줄 수를 최소화하는 것이 코드 품질에 있어 가장 중요하다고 주장한다.
이른바 코드 품질을 개선했더니 3줄이면 끝날 코드가 10줄로 늘어나 코드가 더 나빠졌다는 불만이 간혹 재기된다.

그러나 코드 줄 수는 우리가 실제로 신경 쓰는 것들을 간접적으로 측정해줄 뿐이다.
대부분의 간접 측정이 그렇듯이 유용한 지침 원칙이긴 하지만 반드시 지켜야 할 엄격한 규칙은 아니라는 점을 기억해야 한다.
우리가 정말로 신경 쓰는 것은 코드에 대해 다음과 같은 사항들을 확실하게 하는 것이다.

- 이해하기 쉽다.
- 오해하기 어렵다.
- 실수로 작동이 안 되게 만들기가 어렵다.

모든 코드 라인이 동일한 것은 아니다. 매우 이해하기 어려운 코드 한 줄은 같은 일을 하는 이해하기 쉬운 코드 10줄(또는 심지어 20줄)에 비해 코드 품질을 쉽게 낮출 수 있다.

## 1. 간결하지만 이해하기 어려운 코드는 피하라
코드의 줄 수가 얼마나 적으면 가독성이 떨어지는지 논의하기 위해 예제 5.9를 살펴보자. 이 예제 코드는 16비트 ID가 유효한지 확인하는 함수를 보여준다.
코드를 살펴본 후 자문해보라. 유효한 ID의 기준이 무엇인지 즉시 알 수 있는가? 대부분의 개발자들은 이 질문에 '아니오'라고 답할 것이다.

#### [예제 5.9] 간결하지만 이해하기 어려운 코드
```java
Boolean isIdValid(UInt26 id) {
  return countSetBits(id & 0x7FFF) % 2 == ((id & 0x8000) >> 15);
}
```
이 코드는 패리티 비트를 검사하는데, 이는 데이터를 전송할 때 사용되는 오류 감지를 위한 것이다.
16비트 ID는 하위 15비트에 저장된 값과 최상위 1비트에 저장된 패리티 비트를 포함한다. 패리티 비트는 15비트 값으로 설정된 비트 수가 짝수인지 홀수인지를 나타낸다.

예제 5.9의 코드는 이해하기 어렵고 코드 자체로 설명이 되지도 않는다. 이 코드는 간결하지만 다음과 같이 많은 가정과 복잡성을 가지고 있다.
- ID의 하위 15비트에 값이 포함되어 있다.
- ID의 최상위 비트는 패리티 비트이다.
- 15비트로 표현된 값이 짝수인 경우 패리티 비트는 0이다.
- 15비트로 표현된 값이 홀수인 경우 패리티 비트는 1이다.
- 0x7FFF는 하위 15비트를 위한 비트 마스크다.
- Ox8000은 최상위 비트에 대한 비트 마스크다.

이 모든 세부 사항과 가정을 매우 간결한 단 한 줄의 코드로 압축할 때 다음과 같은 문제가 있다.
- 다른 개발자는 이 단 한 줄의 코드에서 이 모든 세부 사항과 가정을 도출하기 위해 많은 노력을 기울여야 한다.
  이로 인해 그들의 시간이 낭비되고, 또한 코드를 오해하고 코드를 수정할 때 작동하지 않게 될 가능성이 커진다.
- 이런 가정은 다른 코드에서 이루어진 가정과 일치해야 한다. 이 ID를 인코딩하는 코드가 다른 곳에 있다고 하자.
  이 코드에서 패리티 비트를 (예를 들어) 최상위 비트가 아닌 최하위 비트로 사용하도록 코드를 수정하면, 예제 5.9의 코드는 올바르게 작동하지 않는다.
  패리티 비트의 위치를 하위 문제로 만들어 이것을 로직의 유일한 최종 원천(single source of truth)으로 재사용하는 것이 더 나을 것이다.

예제 5.9의 코드는 간결하지만 거의 이해할 수 없다. 여러 개발자는 이 코드가 무엇을 하는지 이해하려고 많은 시간을 낭비할 가능성이 크다.
또한, 이 코드가 전제하고 있는 명확하지 않고 문서화되지 않은 많은 가정으로 인해 코드 수정에 상당히 취약하고, 수정되노 코드가 제대로 동작하지 않기가 쉽다.

## 2. 해결책: 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하라
더 많은 줄의 코드를 작성해서 ID 인코딩 및 패리티 비트에 대한 가정과 세부 사항이 코드를 읽는 누구에게나 더 명백해진다면 그렇게 하는 것이 훨씬 더 좋다.
예제 5.10은 어떻게 예제 5.9의 코드를 읽기 쉽게 만들 수 있는지를 보여준다. 이 코드에서는 잘 명명된 헬퍼 함수와 상수를 정의한다.
이로 인해 코드가 훨씬 더 이해하기 쉽고 하위 문제에 대한 해결책을 재사용할 수 있지만, 코드의 양은 더 많아진다.

#### [예제 5.10] 코드의 양은 더 많지만 가독성은 높은 코드
```java
Boolean isIdValid(UInt16 id) {
  return extractEncodeParity(id) ==
      calculateParity(getIdValue(id));
}

private const UInt16 PARITY_BIT_INDEX = 15;
private const UInt16 PARITY_BIT_MASK = (1 << PARITY_BIT_INDEX);
private const UInt16 VALUE_BIT_MASK = ~PARITY_BIT_MASK;

private UInt16 getIdValue(UInt16 id) {
  return id & VALUE_BIT_MASK;
}

private UInt16 extractEncodeParity(UInt16 id) {
  return (id & PARITY_BIT_MASK) >> PARITY_BIT_INDEX;
}

// 패리티 비트는 1인 비트의 수가 짝수이면 0이고
// 홀수이면 1이다.
private UInt16 calculateParity(UInt16 value) {
  return countSetBits(value) % 2;
}
```

코드의 줄 수가 많다는 것은 기존 코드를 재사용하지 않거나 무언가를 필요 이상으로 복잡하게 만들 수 있다는 경고 신호가 될 수 있다.
따라서 추가되는 코드의 줄 수를 주시하는 것이 일반적으로는 바람직하다.
그러나 이것보다 더 중요한 것은 코드가 이해하기 쉬워야 하고, 어떤 상황에서도 잘 동작하며, 문제가 되는 동작을 할 가능성은 없는지 확인하는 것이다.
