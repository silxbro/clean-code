# 가정을 주의하라
<br/>

코드 작성 시 가정을 하면 코드가 더 단순해지거나, 더 효율적으로 되거나, 둘 다일 수도 있다.
그러나 이러한 가정으로 인해 코드가 더 취약해지고 활용도가 낮아져 재사용하기에 안전하지 않을 수 있다.
코드의 어느 부분에서 어떤 가정이 이루어졌는지 정확히 추적하는 것은 극도로 어렵기 때문에 이런 가정은 다른 개발자들이 주의하지 않으면 빠질 수 있는 기분 나쁜 함정이 될 수 있다.
처음에 코드를 개선하는 쉬운 방법처럼 보였던 것이 코드가 재사용되자마자 버그와 이상한 동작이 나타나고 실제로는 의도한 것과는 반대의 효과를 가져올 수 있다.

이러한 점을 고려할 때, 코드 작성 시 가정을 하기 전에 그 가정으로 초래될 비용과 이점을 생각해 봐야 한다.
코드 단순화 또는 효율성의 명백한 이득이 미미하다면 늘어난 취약성으로 인한 비용이 장점을 능가하기 때문에 가정을 하지 않는 것이 최선일 수 있다. 다음 하위 절에서 이에 대해 살펴본다.
<br/>
<br/>
## 1. 가정은 코드 재사용 시 버그를 초래할 수 있다
예제 9.1 코드를 살펴보자. Article 클래스는 사용자가 읽을 수 있는 뉴스 웹 사이트의 기사를 나타낸다. getAllImages() 함수는 기사에 포함된 모든 이미지를 반환한다.
이를 위해 이미지가 포함된 섹션을 찾을 때까지 문서 내의 섹션을 반복해서 확인하고 해당 섹션의 이미지를 반환한다. 이 코드는 이미지가 포함된 섹션이 하나만 있을 것이라고 가정한다.
이 가정은 코드 내에서 주석문으로 설명되지만, 코드를 사용하는 쪽에서는 알 수 없다.

이러한 가정을 함으로써 코드는 이미지를 포함하는 부분이 발견되자마자 for-loop를 종료하기 때문에 성능이 아주 미약하게 향상되지만, 이 이득이 너무 작아서 실제로는 중요하지 않다.
그러나 이미지가 있는 섹션이 두 개 이상인 기사에 getAllImages() 함수가 사용될 경우 모든 이미지를 반환하지 않는다는 사실이 중요하다.
이런 일은 일어날 가능성이 매우 높고, 그로 인해 버그를 초래할 가능성이 있다.

#### [예제 9.1] 가정을 포함하는 코드
```java
class Article {
  private List<Section> sections;
  ...

  List<Image> getAllImages() {
    for (Section section in sections) {
      if (section.containsImage()) {
        // 기사 내에 이미지를 포함하는 섹션은 최대 하나만 있다.
        // ---> 코드 내에서 주석문으로 설명된 가정
        return section.getImages();  // 이미지를 가지고 있는 첫 번째 섹션의 이미지만 반환한다.
      }
    }
    return [];
  }
}
```
이미지 섹션이 하나만 있을 것이라는 가정은 코드 작성자가 염두에 둔 원래의 사용 사례에서 의심할 여지없이 정확한 것이었다.
그러나 Article 클래스가 다른 용도로 재사용되거나 기사 내의 이미지 배치가 변경되는 경우 이 가정은 부정확한 것이 될 수 있다.
그리고 이 가정은 코드 깊숙한 곳의 주석문 속에 묻혀 있기 때문에 호출하는 쪽에서 이것을 인지할 가능성은 매우 낮다.
누구든지 getAllImages()라는 함수를 보면 '모든' 이미지를 반환한다고 가정할 것이다. 불행하게도 이것은 숨겨진 가정이 사실일 때만 올바르다.

## 2. 해결책: 불필요한 가정을 피하라
이미지 섹션이 하나만 있다고 가정하는 것의 비용-이익 상충관계를 고려하면 그 가정이 별로 가치가 없을 수도 있다.
다른 한편으로는 (눈에 거의 띄지 않을 것 같은) 약간의 성능 향상이 있지만, 다른 한편으로는 코드를 재사용하거나 요구 사항이 변경되면 버그가 발생할 가능성이 있다.
따라서 이 가정을 하지 않는 것이 더 나을 수도 있다. 이 가정으로 인해 얻는 것은 거의 없고 위험만 늘어난다.

#### [섣부른 최적화]
섣부른 최적화를 피하려는 열망은 소프트웨어 공학과 컴퓨터 과학 내에서 잘 정립된 개념이다. 코드 최적화는 일반적으로 비용이 든다.
즉, 최적화된 해결책을 구현하는 데 더 많은 시간과 노력이 필요하며 그 결과 코드는 종종 가독성이 떨어지고, 유지 관리가 더 어려워지며, 가정을 하게 되면 견고함이 떨어질
가능성이 있다. 게다가 최적화는 보통 프로그램 내에서 수천 번 혹은 수백만 번 실행되는 코드 부분에 대해 이루어질 때 상당한 이점이 있다.<br/>
따라서 대부분의 경우에는 큰 효과 없는 코드 최적화를 하느라고 애쓰기보다는 코드를 읽을 수 있고 유지보수 가능하며, 견고하게 만드는 데 집중하는 것이 좋다.
코드의 어떤 부분이 여러 번 실행되고 그 부분을 최적화하는 것이 성능 향상에 큰 효과를 볼 수 있다는 점이 명백해질 때에라야 최적화 작업을 해도 무방하다.

예제 코드 9.2는 앞서 했던 가정을 없애고 getAllImages() 함수가 이미지가 포함된 첫 번째 섹션이 아닌 모든 섹션의 이미지를 반환하도록 변경된 코드를 보여준다.
따라서 다양한 사용 사례에 대해 훨씬 더 다재다능하고 견고하다.
단점으로는 for 루프가 몇 번 더 반복한다는 것이지만, 방금 언급한 것처럼 눈에 띌 정도로 성능에 영향을 미칠 가능성은 작다.

#### [예제 9.2] 가정을 제거한 코드
```java
class Article {
  private List<Section> sections;
  ...

  List<Image> getAllImages() {  // 모든 섹션에서 이미지를 모아서 반환한다.
    List<Image> images = [];
    for (Section section in sections) {
      images.addAll(sections.getImages());
    }
    return images;
  }
}
```
코드를 작성할 때 필요 이상으로 성능비용과 같은 문제에 주의를 기울이는 경우가 있다.
그러나 코드에 가정이 들어가면 취약성의 측면에서도 관련 비용을 수반한다는 것을 기억하는 것이 중요하다.
특정한 가정으로 인해 성능이 눈에 띄게 향상되거나 코드가 크게 단순해진다면, 그 가정은 충분히 가치 있는 것일 수 있다.
그러나 가정으로 인해 얻는 이득이 미미하다면, 오히려 비용이 이점보다 훨씬 클 수 있다.

## 3. 해결책: 가정이 필요하면 강제적으로 하라
때로는 가정이 필요하거나 가정으로 얻는 이득이 비용을 초과할 정도로 코드가 단순해질 수 있다.
코드에 가정이 있을 때, 다른 개발자들이 그것을 여전히 모를 수 있다는 사실을 염두에 두어야 한다.
그래서 우리가 상정한 가정으로 인해 다른 개발자들이 무의식중에 곤란을 겪지 않도록 하기 위해 가정을 강제적으로 시행해야 한다.
이를 위해 일반적으로 다음 두 가지 방법을 사용할 수 있다.

1. **가정이 '깨지지 않게' 만들라**
   - 가정이 깨지면 컴파일되지 않는 방식으로 코드를 작성할 수 있다면 가정이 항상 유지될 수 있다. (3장, 7장)
2. **오류 전달 기술을 사용하라**
   - 가정을 깨는 것이 불가능하게 만들 수 없는 경우에는 오류를 감지하고 오류 신호 전달 기술을 사용하여 신속하게 실패하도록 코드를 작성할 수 있다. (3장, 4장)
  
### 문제의 소지가 있는, 강제되지 않은 가정
강제되지 않은 가정이 어떻게 문제가 될 수 있는지 설명하기 위해 Article 클래스에 포함될 수 있는 다른 함수, 즉 이미지 섹션을 반환하는 함수를 살펴보자.
예제 9.3은 가정을 강제적으로 시행하지 않는 경우 함수의 코드를 보여준다.
섹션에 대해 이미지가 포함됐는지 확인하고, 그 섹션이 이미지가 포함된 첫 번째 섹션이면 그 섹션을 반환하고, 이미지가 포함된 섹션이 없는 경우 널을 반환한다.
다시 한번 이 코드는 모든 기사는 이미지를 갖는 섹션이 최대 하나만 있다고 가정한다.
이 가정이 깨지고 문서에 여러 이미지 섹션이 포함되어 있더라도 코드는 실패하지 않고 어떤 종류의 경고도 생성하지 않는다.
대신에 이미지를 갖는 첫 번째 섹션을 반환하고 모든 것이 문제없는 것처럼 계속 진행할 것이다(이것은 신속하게 실패하는 것의 반대다).

#### [예제 9.3] 가정을 포함하는 코드
```java
class Article {
  private List<Section> sections;
  ...

  Section? getImageSection() {
    // 기사 내에 이미지를 포함하는 섹션은 최대 하나만 있다.
    return sections  // 이미지를 갖는 첫 번째 섹션을 반환하거나 이미지를 갖는 섹션이 없는 경우 널을 반환한다.
        .filter(section -> section.containsImages())
        .first();
  }
}
```
getImageSection() 함수는 사용자에게 기사를 보여주는 코드에 의해 호출되는데, 예제 9.4에 이 코드가 나와 있다. 
문서를 표시하는 템플릿에는 이미지 섹션에 대한 공간이 하나만 있다. 따라서, 이 특정 사용 사례에서는 기사에 이미지를 갖는 섹션이 최대 하나만 있다는 가정이 필요하다.

#### [예제 9.4] 가정에 의존하는 호출자
```java
class ArticleRenderer {
  ...

  void render(Article article) {
    ...
    Section? imageSection = article.getImageSection();  // 기사 템플릿은 이미지를 갖는 섹션을 최대 하나만 처리할 수 있다.
    if (imageSection != null) {
      templateData.setImageSection(imageSection);
    }
    ...
  }
}
```
만약 누군가가 이미지가 들어 있는 섹션이 여러 개 있는 문서를 작성한 후에 이 코드를 사용한다면, 코드가 이상하고 예상치 못한 방식으로 동작하는 것을 알게 될 것이다.
오류나 경고가 발생하지 않기 땜누에 모든 것이 잘 작동하는 것처럼 보이지만, 실제로는 많은 이미지가 누락된 채 기사가 보일 것이다.
기사의 성격에 따라 오해의 소지가 있거나 완전히 터무니없는 결과를 초래할 수도 있다.

### 가정의 강제적 확인
4장에서 언급한 바와 같이 일반적으로 실패와 오류는 명확하게 드러나는 것이 최선이다. 이 예에서 여러 이미지 섹션으로 된 문서를 나타내는 것이 지원되지 않으므로 오류다.
이 경우 코드가 이상하게 동작하기보다는 신속하게 실패하는 것이 더 나을 것이다.
오류 전달 기법을 사용하여 가정을 강제로 인지하게 함으로써 신속하게 실패하기 위한 코드로 변경할 수 있다.

예제 9.5는 Article.getImageSection() 함수가 어서션을 사용하여 최대 하나의 이미지 섹션이 있다고 가정할 때의 코드를 보여준다.
또한, 함수 이름을 getOnlyImageSection()으로 변경해 이 함수의 호출자에게 이미지 섹션이 하나만 있다고 가정할 수 있다.
이렇게 함으로써 이 가정을 원치 않는다면 이 함수를 호출하지 않도록 할 수 있다.

#### [예제 9.5] 가정의 강제적 확인
```java
class Article {
  private List<Section> sections;
  ...

  Section? getOnlyImageSection() {  // 함수의 이름은 호출자가 할 가정을 나타낸다.
    List<Section> imageSections = sections
        .filter(section -> seciton.containsImages());

    assert(imageSections.size() <= 1,
          "기사가 여러 개의 이미지 섹션을 갖는다");  // 어서션은 이 가정을 강제로 확인한다.
    return imageSections.first();  // imageSections 리스트에서 첫 번째 항목을 반환하거나 리스트가 비어 있으면 널을 반환한다.
  }
}
```

#### [오류 전달 기법]
4장에서는 여러 가지 오류 전달 기법에 대해 자세히 논의했는데, 특히 호출하는 쪽에서 오류로부터 복구하기를 원하는지의 여부에 따라 어떻게 기법의 선택이 달라지는지 살펴봤다.<br/>
예제 9.5는 어서션을 사용하는데 호출하는 쪽에서 오류로부터 복구하기를 원하지 않는 경우에 적합하다.
기사가 프로그램 내에서 내부적으로 생성된다면 가정을 깨는 것은 프로그래밍 오류를 의미하며, 이는 어서션이 적절하다는 것을 의미한다.
하지만 외부 시스템이나 사용자에 의해 기사가 제공된다면, 호출하는 쪽에서 더 매끄러운 방식으로 오류를 처리하기를 원할 수도 있다.
이 경우에는 명시적인 오류 전달 기법이 더 적절할 수 있다.
<br/>
이미 살펴봤듯이 가정은 취약성의 증가라는 측면에서 관련 비용을 수반하는 경향이 있다.
가정 때문에 치러야 할 비용이 그 가정으로 인해 얻는 이득보다 크다면, 가정을 하지 않는 것이 최선일 것이다.
가정이 필요하다면 다른 개발자가 그 가정으로 인해 오류에 빠지지 않도록 최선을 다해야 한다. 가정을 강제로 시행함으로써 이를 달성할 수 있다.
