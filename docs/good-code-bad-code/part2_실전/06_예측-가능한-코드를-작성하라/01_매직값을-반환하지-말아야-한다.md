# 매직값을 반환하지 말아야 한다
<br/>

**매직값**(magic value)은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다.
매직값의 일반적인 예는 값이 없거나 오류가 발생했음을 나타내기 위해 -1을 반환하는 것이다.

매직값은 함수의 정상적인 반환 유형에 들어맞기 때문에 이 값이 갖는 특별한 의미를 인지하지 못하고, 이에 대해 적극적으로 경계하지 않으면 정상적인 반환값으로 오인하기 쉽다.
이번 절에서는 이런 상황이 어떻게 예측을 벗어나는 코드가 될 수 있는지, 그리고 매직값을 피할 수 있는 방법ㅂ에 대해 설명한다.
<br/>
<br/>
## 1. 매직값은 버그를 유발할 수 있다
값이 없음을 나타내기 위해 함수에서 -1을 반환하는 것을 접한 적이 있을 것이다.
일부 레거시 코드와 언어의 내장된 함수들(ex: 자바스크립트에서 배열에 대해 indexOf()를 호출할 때) 중에 이런 경우가 있다.

과거에는 더 명시적인 오류 전달 기법이나 널 또는 옵셔널 타입을 반환하는 것이 가능하지 않거나, 실용적이지 않기 때문에
(-1과 같은) 매직값을 반환하는 것이 어느 정도 합리적인 이유가 있었다. 레거시 코드로 작업 중이거나, 신중하게 최적화해야 하는 코드가 있다면 여전히 이렇게 할 이유가 있을 수 있다.
그러나 일반적으로 매직값을 반환하면 예측을 벗어날 위험이 있으므로 사용하지 않는 것이 가장 바람직하다.

매직값이 어떻게 버그를 유발할 수 있는지 살펴보기 위해 예제 6.1 코드를 살펴보자. 이 코드는 사용자에 대한 정보를 저장하는 클래스를 보여준다.
클래스에 저장된 정보 중 하나는 사용자의 나이이며, 이 정보는 getAge() 함수를 호출하여 액세스할 수 있다.
getAge() 함수는 널이 아닌 정수를 반환하므로 다른 개발자가 이 함수 시그니처를 보면 반환값은 항상 사용 가능하다고 가정할 수 있다.

#### [예제 6.1] User 클래스 및 getAge() 함수
```java
class User {
  ...
  Int getAge() { ... }  // 사용자의 나이를 반환하는데 널값은 반환되지 않는다.
}
```
이제 서비스의 모든 사용자에 대한 몇 가지 통계를 계산해야 한다고 가정해보자. 계산해야 할 통계 중 하나는 사용자의 평균 연령이다. 이를 위해 예제 6.2와 같은 코드를 작성한다.
이 코드는 사용자의 모든 연령을 합산한 다음 이를 사용자 수로 나눈다. 이 코드는 user.getAge()가 항상 사용자의 실제 연령을 반환한다고 가정한다.
코드의 어떤 부분도 확실하게 잘못된 것으로 보이지 않기 때문에, 이 코드의 작성자와 검토자는 이 코드의 동작에 만족할 것이다.

#### [예제 6.2] 사용자 평균 연령 계산
```java
Double? getMeanAge(List<User> users) {
  if (users.isEmpty()) {
    return null;
  }
  Double sumOfAges = 0.0;
  for (User user : users) {
    sumOfAges += user.getAge().toDouble();  // user.getAge()이 모든 반환값을 더한다.
  }
  return sumOfAges / user.size().toDouble();
}
```
이어지는 예제 코드에서 살펴보겠지만 실제로 이 코드는 제대로 작동하지 않으며 모든 사용자가 나이를 제공하는 것은 아니기 때문에
평균 연령에 대한 잘못된 값을 반환하는 경우가 있을 수 있다. 이 경우 User.getAge() 함수는 -1을 반환할 것이다.<br/>
이 내용은 코드의 세부 조항에 언급되어 있는데 불행하게도 getMeanAge() 함수의 작성자는 (주석문 안에 세부 조항이 파묻혀 있을 때 흔히 그렇듯이) 이것을 깨닫지 못했다.

예제 6.3의 User 클래스를 좀 더 자세히 살펴보면 이것을 알 수 있다.
User.getAge()가 호출자에게 명시적으로 알리지 않고 마이너스 1을 반환한다는 사실은 getMeanAge() 함수의 작성자가 예측하지 못한 것이기 때문에 이 사실은 불쾌하고 놀라울 수 있다.
getMeanAge() 함수는 그럴듯하게 보이는 값을 반환하겠지만 평균값 계산 과정에서 -1이 포함되었을 가능성이 있기 때문에 잘못된 값일 수 있다.

#### [예제 6.3] User 클래스의 상세 내용
```java
class User {
  private final Int? age;  // 나이가 주어지지 않았을 수 있다.
  ...

  // 나이가 주어지지 않은 경우에는 -1을 반환한다. ---> (주석문 안에 있는) 세부 조항은 getAge()가 -1을 반환할 수 있음을 말한다.
  Int getAge() {
    if (age == null) {
      return -1;  // 나이가 주어지지 않으면 -1을 반환한다.
    }
    return age;
  }
}
```
이것이 성가시긴 하지만 치명적이지는 않은 버그로 보일 수도 있는데, 이 코드가 정확히 어디서 어떻게 불리고 있는지 알지 못하면 치명적인지 아닌지를 결정할 수가 없다.
주주들에게 보내는 회사의 연례 보고서에 대한 통계를 준비하는 팀이 getMeanAge() 함수를 재사용한다고 가정해보자.
보고서에 나온 사용자의 평균 연령은 회사 주가에 큰 영향을 미칠 수 있다. 보고된 내용이 올바르지 않으면 심각한 법적 결과를 초래할 수도 있다.

또 하나 주의할 점은 단위 테스트가 이 문제를 발견하지 못할 수 있다는 점이다.
getMeanAge() 함수의 작성자는 사용자 클래스에 나이가 반드시 있을 것이라는 확고한 (하지만 잘못된) 믿음을 가지고 있다.
User 클래스에 나이가 없을 수도 있다는 것을 알지 못하기 때문에 단위 테스트 코드에 사용되는 User 클래스의 모든 인스턴스가 나이를 가지고 있을 가능성이 크다.

테스트는 좋은 것이지만, 예측을 벗어나는 코드를 작성한다면 이 코드가 만들어 놓은 덫에 빠지지 않기 위해서는 누군가 모든 상황을 부지런히 확인해야 한다.
하지만 어느 순간 이런 일이 일어나지 않을 수 있고 누군가는 그 함정에 빠져들 것이다.

## 2. 해결책: 널, 옵셔널 또는 오류를 반환하라
3장에서는 코드 계약에는 명백한 항목과 세부 조항이 포함된다는 점을 살펴봤다. 함수에서 매직값을 반환할 때의 문제점은 호출하는 쪽에서 함수 계약의 세부 조항을 알아야 한다는 점이다.
어떤 개발자들은 이 세부 조항을 확인하지 않거나 확인하고나서 잊어버린다. 이런 경우에는 예측을 벗어나는 일이 생길 수 있다.

값이 없을 수 있는 경우 이것이 코드 계약의 명백한 부분에서 확인할 수 있도록 하는 것이 훨씬 좋다.
이를 위한 쉬운 방법 중 하나는 널 안전성을 지원하는 경우에는 **널이 가능한 유형을 반환**하고, 널 안전성을 지원하지 않는 경우에는 **옵셔널 값을 반환**하는 것이다.
이를 통해 호출하는 쪽에서 값이 없을 수 있음을 인지하고 적절한 방법으로 이를 처리할 수 있게 해야 한다.

예제 6.4 코드는 값이 제공되지 않은 경우 널을 반환하도록 getAge() 함수를 수정한 User 클래스를 보여준다.
널 안전성은 호출하는 쪽에서 getAge()가 널을 반환할 수 있다는 사실을 인식할 수밖에 없도록 만든다.
사용 중인 언어에서 널 안전성을 지원하지 않는 경우 Optional<Int>를 반환하면 같은 효과가 있다.

#### [예제 6.4] 널을 반환하도록 수정된 getAge()
```java
class User {
  private final Int? age;  // 나이는 주어지지 않을 수 있다. (?는 나이가 널일 수 있음을 의미한다)
  ...

  Int? getAge() {  // 반환 타입은 널이 가능하다.
    return age;  // 나이가 주어지지 않으면 널을 반환한다.
  }
}
```
잘못된 getMeanAge() 함수는 컴파일러 오류를 발생시키며, 이 함수를 작성한 개발자는 코드에 잠재적인 버그가 있다는 것을 깨닫는다.
getMeanAge() 코드를 컴파일하기 위해 개발자는 User.getAge()가 널을 반환하는 경우를 처리해야 한다.

#### [예제 6.5] 오류가 있는 코드는 컴파일되지 않는다
```java
Double? getMeanAge(List<User> users) {
  if (users.isEmpty()) {
    return null;
  }
  Double sumOfAges = 0.0;
  for (User user : users) {
    sumOfAges += user.getAge().toDouble();  // getAge()는 널을 반환할 수 있기 때문에 컴파일러 오류를 유발한다.
  }
  return sumOfAges / users.size().toDouble();
}
```
이 문제를 좀 더 조직과 제품의 관점에서 본다면, 널이 가능한 유형을 반환하면 개발자들은 사용자들의 평균 연령을 계산하는 것이 처음에 생각했던 것만큼 간단하지 않다는 것을 깨닫는다.
이 정보를 기반으로 요구 사항을 개선해야 할 수도 있기 때문에 개발자는 관리자나 제품팀에 이 사실을 알릴 수 있다.

널값이나 비어 있는 옵셔널을 반환하는 것의 단점은 값이 없는 이유를 명시적으로 전달하지 않는다는 점이다.
사용자의 나이가 값을 제공하지 않았기 때문에 널인지, 혹은 시스템에서 오류가 발생하여 널인지 알 수 없다.
이러한 상황을 구별하는 것이 필요하다면 4장에서 설명한 오류 전달 기법을 사용하는 것을 고려해야 한다.

#### [널이 가능한 반환 유형은 호출하는 쪽에 부담을 주지 않는가?]
이것에 대한 짧은 대답은 종종 '그렇다'이다. 만약 함수가 널값을 반환할 수 있다면 호출하는 쪽에서는 값이 널인 경우를 처리하기 위해 코드를 추가로 작성해야 할 때가 많다.
일부 개발자들은 이것을 널값이나 옵셔널 유형을 반환하는 것에 대한 반대 이유로 언급하지만 대안이 무엇일지 고려해볼 가치가 있다.<br/>
만약 어떤 값이 존재하지 않을 수 있고 함수가 이 사실을 분명하게 알려주지 않는다면, 버그를 갖는 코드를 작성하게 될 위험이 도사리고 있다.
중장기적으로 이와 같은 버그를 처리하고 고치는 노력과 비용은 널 반환값을 올바르게 처리하기 위해 코드 몇 줄 더 추가하는 비용보다 훨씬 높을 수 있다.<br/>
6.2절에서는 널 반환의 대안으로 사용하기도 하는 **널 객체 패턴**(null object pattern)에 대해 논의한다. 하지만 이후에 살펴보겠지만, 이것 역시 부적절하게 사용하면 문제가 될 수 있다.<br/>
널값을 반환하는 것에 반대하는 또 다른 이유는 NullPointerException과 NullReferenceException, 혹은 그와 비슷한 예외의 위험 때문이다.
그러나 2장(2.1절)과 부록 B에서 논의하는 바와 같이 널 안전성이나 옵셔널 유형을 사용하면 일반적으로 이러한 위험이 없어진다.

## 3. 때때로 매직값이 우연히 발생할 수 있다
매직값 반환이 반드시 개발자의 의도에 의해서만 되는 것은 아니다.
개발자가 자신의 코드에 주어지는 모든 입력과 이러한 입력값들이 어떤 영향을 미칠 수 있을지에 대해 충분히 생각하지 않을 때도 매직값은 반환될 수 있다.

정숫값 리스트에서 최솟값을 찾는 예제 6.6 코드를 통해 이에 대해 살펴보자. 아래 예제 코드에서 함수는 주어진 리스트가 비어 있으면 매직값(Int.MAX_VALUE)을 반환한다.

#### [예제 6.6] 최솟값 찾기
```java
Int minValue(List<Int> values) {
  Int minValue = Int.MAX_VALUE;
  for (Int value in values) {
    minValue = Math.min(value, minValue);
  }
  return minValue;  // values 리스트가 비어 있으면 Int.MAX_VALUE가 반환된다.
}
```
이 코드를 작성한 개발자에게 물어봐야 하겠지만, Int.MAX_VALUE가 그저 우연히 반환되는 것이 아닐 수 있다.
이 값을 반환하는 것의 타당성에 대해 이 코드이의 작성자가 제시할 만한 몇 가지 논거는 다음과 같다.
- 빈 목록에 대해 최솟값을 얻는 것은 의미가 없다는 점을 호출하는 쪽에서 명확하게 알고 있기 때문에 이 경우 어떤 값이 반환되더라도 중요하지 않다.
- Int.MAX_VALUE보다 더 큰 정수는 없으므로 이 값은 반환하기에 적합하다
  이 반환값은 어떤 종류의 임곗값과도 비교할 수 있고, 그 비교 결과 실행할 논리가 있다면 그것은 올바르게 동작할 것이다.

이러한 주장의 문제점은 함수가 어떻게 호출되고 결과가 어떻게 사용될지에 대해 가정을 한다는 것이다.
이러한 가정들은 잘못된 것일 수 있고 그 경우 코드는 예측을 벗어나는 동작을 할 것이다.

Int.MAX_VALUE를 반환할 때 적절한 기본(default) 로직이 실행되지 않을 수도 있다. 이것의 예로는 **최대최소**(maximin) 알고리즘의 일부로서 이 예제와 같은 코드를 사용하는 경우다.
여러분이 어떤 게임을 위한 개발팀의 일원이고, 그 게임에서 어느 레벨이 가장 쉬운지 결정해야 한다고 가정해보자.
이를 위해 각 레벨에 대해 사용자들이 획득한 최소 점수를 계산한 후에 이 중에서 최소 점수가 가장 높은 레벨이 가장 쉬운 레벨이라고 결정하기로 했다.

예제 6.7은 이 개발팀의 누군가가 작성할 법한 코드를 보여준다. 이 코드는 방금 전 살펴본 minValue() 함수를 활용한다.
코드를 실행해보면 레벨 14가 가장 쉬운 레벨이라고 출력된다. 현실적으로 레벨 14는 너무 어려워 아무도 그 레벨을 완성하지 못했다.
따라서 레벨 14에 대해서는 점수가 기록조차 된 적이 없다. 레벨 14를 처리할 때 minValue() 함수는 빈 리스트로 호출되어 Int.MAX_VALUE를 반환한다.
이로 인해 레벨14가 가장 높은 최소 점수를 가진 레벨로 결정된다. 하지만 실제로는 레벨 14가 너무 어려워서 아무도 완성하지 못했고 채점된 점수가 없는 것이었다.

#### [예제 6.7] 최대최소 알고리즘
```java
class GameLevel {
  ...
  List<Int> getAllScores() { ... }  // 기록된 점수가 없으면 빈 리스트가 반환된다.
}

GameLevel? getEasiestLevel(List<GameLevel> levels) {
  GameLevel? easiestLevel = null;
  Int? highestMinScore = null;
  for (GameLevel level int levels) {
    Int minScore = minValue(level.getAllScores());  // 점수가 없으면 Int.MAX_VALUE가 반환된다.
    if (highestMinScore == null || minScore > highestMinScore) {
      easiestLevel = level;
      highestMinScore = minScore;
    }
  }
  return easiestLevel;  // 어떤 레벨에 대해 기록된 점수가 없다면 그 레벨이 반환된다.
}
```
Int.MAX_VALUE가 문제가 될 수 있는 다른 경우도 있다.
- Int.MAX_VALUE는 사용 중인 프로그래밍 언어에 따라 달라지는 경우가 많다.
  minValue() 함수가 자바 서버 환경에 실행되고, 이 함수의 응답이 자바스크립트로 작성된 클라이언트 측 애플리케이션으로 전송된다면 이 값의 의미가 분명하지 않다.
  자바에서의 Integer.MAX_VALUE와 자바스크립트에서의 Number.MAX_SAFE_INTEGER는 아주 다른 값이다.
- minValue() 함수의 반환값이 데이터베이스에 저장되는 경우에는 쿼리를 실행하는 사용자나 데이터베이스를 읽는 다른 시스템에 많은 혼란과 문제를 야기할 수 있다.

따라서 minValue() 함수는 널값이나 빈 옵셔널을 반환하거나 오류 전달을 하는 것이 더 낫고, 이에 따라 호출하는 쪽에서는 어떤 입력에 대해서는 값을 계산하지 못할 수 있음을
알아야 한다. 만약 널값을 반환하도록 코드를 작성한다면, 이를 처리하기 위한 코드를 작성해야 하기 때문에 호출하는 쪽에 추가적인 부담을 준다.
그러나 이렇게 하면 그렇게 하지 않을 경우에 호출하는 쪽에서 해야만 하는 작업, 예를 들면 minValue()를 호출하기 전에 목록이 비어 있는지 확인할 필요가 없고,
이런 확인 없이 버그가 발생할 가능성이 있는 코드를 실행하는 위험 또한 없어진다. 다음 예제 코드는 빈 리스트에 대해 널값을 반환할 경우 minValue() 함수가 어떻게 되는지 보여준다.

#### [예제 6.8] 빈 리스트에 대한 널값 반환
```java
Int? minValue(List<Int> values) {
  if (values.isEmpty()) {
    return null;  // values 리스트가 비어 있으면 널값을 반환한다.
  }
  Int minValue = Int.MAX_VALUE;
  for (Int value int values) {
    minValue = Math.min(value, minValue);
  }
  return minValue;
}
```
매직값을 반환하는 것이 때로는 개발자가 의식적으로 내린 결정이지만, 어떤 경우에는 우연히 일어날 수도 있다.
이유 여하를 막론하고 매직값은 예측을 벗어나는 결과를 초래할 수 있기 때문에 발생 가능한 상황에 대해 조심하는 것이 좋다.
매직값보다는 **널값이나 옵셔널을 반환**하거나 **오류 전달 기술을 사용**하는 것이 간단하고 효과적인 대안이다.

#### [프로그래밍 언어 기능의 적절한 사용]
minValue() 예제는 매직값 반환에 대한 일반적인 사항을 설명하기 위한 것이었다.
정수 리스트에서 최솟값을 찾아 주는 프로그래밍 언어 기능이 있거나 기존 유틸리티가 있다면 그것을 사용하는 것이 더 낫다.
