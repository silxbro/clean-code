# 좋은 단위 테스트는 어떻게 작성할 수 있는가?
<br/>

액면 그대로의 단위 테스트는 매우 간단해보일지 모른다. 실제 코드가 작동하는지 확인하기 위해 테스트 코드를 작성하기만 하면 된다.
안타깝게도 이는 기만적인 것이며, 수년 동안 많은 개발자가 쉽게 단위 테스트를 잘못된 방식으로 작성해 왔다.
단위 테스트에서 문제가 발생하면 유지 관리가 매우 어렵고, 버그가 테스트 코드에서 발견되지 못하고 배포한 뒤에 발생할 수도 있다.
그러므로 어떻게 해야 좋은 단위 테스트가 되는지 생각해보는 것이 중요하다. 이를 위해 좋은 단위 테스트가 가져야 할 5가지 주요 기능을 정의한다.

- **훼손의 정확한 감지**
  - 코드가 훼손되면 테스트가 실패한다. 그리고 테스트는 코드가 실제로 훼손된 경우에만 실패해야 한다.
- **세부 구현 사항에 독립적**
  - 세부 구현 사항을 변경하더라도 테스트 코드는 변경하지 않는 것이 이상적이다.
- **잘 설명되는 실패**
  - 코드가 잘못되면 테스트는 실패의 원인과 문제점을 명확하게 설명해야 한다.
- **이해할 수 있는 테스트 코드**
  - 다른 개발자들이 테스트 코드가 정확히 무엇을 테스트하기 위한 것이고 테스트가 어떻게 수행되는지 이해할 수 있어야 한다.
- **쉽고 빠르게 실행**
  - 개발자는 일상 작업 중에 단위 테스트를 자주 실행한다. 단위 테스트가 느리거나 실행이 어려우면 개발 시간이 낭비된다.

다음 하위 절에서는 이러한 목표에 대해 자세히 설명한다.
<br/>
<br/>
## 1. 훼손의 정확한 감지
단위 테스트의 가장 명확하고 주된 목표는 코드가 훼손되지 않았는지 확인하는 것이다. 즉, 코드가 의도된 대로 수행하며 버그가 없다는 사실을 확인하는 것이다.
테스트 중인 코드가 어떤 식으로든 훼손되면 컴파일되지 않거나 테스트가 실패해야 한다. 이것은 매우 중요한 두 가지 역할을 수행한다.

- **코드에 대한 초기 신뢰를 준다.**
  - 아무리 신중하게 코드를 작성해도 실수는 있기 마련이다.
    새로운 코드나 코드 변경 사항과 함께 철저한 테스트 코드를 작성하면 코드가 코드베이스로 병합되기 전에 이러한 실수를 발견하고 수정할 수 있다.
- **미래의 훼손을 막아준다.**
  - 3장에서 코드베이스는 여러 개발자에 의해 변경 작업이 지속적으로 활발하게 이루어지는 장소라는 점을 살펴봤다.
    어느 시점에 다른 개발자가 코드를 변경하는 과정에서 실수로 코드를 훼손할 가능성이 크다.
    이것에 대한 유일한 효과적인 방어 방법은 코드가 컴파일을 중지하거나 테스트가 실패하는 것이다.
    어떤 것이 고장 났을 때 코드가 컴파일을 멈추도록 하는 것은 불가능하므로 모든 올바른 동작을 테스트를 통해 확인하는 것이 절대적으로 중요하다.
    코드 변경(또는 다른 이벤트)으로 인해 잘 돌아가던 기능이 작동하지 않는 것을 **회귀**(regression)라고 한다.
    이러한 회귀를 탐지할 목적으로 테스트를 실행하는 것을 **회귀 테스트**(regression test)라고 한다.

정확성의 또 다른 측면을 고려하는 것도 중요하다. 테스트 대상 코드가 실제로 훼손된 경우에만 테스트가 실패해야 한다.
방금 논의한 내용에 따르면 당연히 그렇게 될 것 같지만 실제로는 그렇지 않은 경우가 많다.
논리적 오류를 경험한 적이 있는 사람이라면 누구나 알겠지만, '코드가 훼손되면 반드시 실패한다'는 것이 반드시 '코드가 훼손될 때만 테스트가 실패한다'는 것을 의미하는 것은 아니다.

테스트 대상 코드가 정상임에도 불구하고 때로는 통과하고 때로는 실패하는 테스트를 **플래키**(flatkey)라고 한다.
이것은 보통 무작위성, 타이밍 기반 레이스(timing-based race) 조건, 외부 시스템에 의존하는 등의 테스트의 비결정적(indeterministic) 동작에 기인한다.
플래키 테스트의 가장 분명한 단점은 개발자들이 결국에는 아무것도 아닌 것으로 판명 날 실패의 원인을 찾느라 시간을 낭비한다는 점이다.
하지만 플래키 테스트는 언뜻 보기보다 훨씬 더 위험하다. '양치기 소년' 우화를 알고 있는 사람이라면 누구나 그 이유를 이해할 것이다.
만약 테스트가 계속해서 실패하면서 코드가 훼손됐다고 잘못된 경고를 보인다면, 이내 그 경고를 무시하게 될 것이다. 정말 짜증나면 아예 테스트를 비활성화할 수도 있다.
더 이상 아무도 테스트 실패에 주의를 기울이지 않는다면 테스트가 없는 상황과 다를 바 없다.
그렇게 되면 코드는 앞으로 일어날 훼손으로부터 보호되지 못하고, 버그가 유입될 가능성이 커진다.
코드에서 어떤 부분이 훼손될 때 그리고 오직 훼손된 경우에만 테스트가 실패하도록 하는 것은 매우 중요하다.

## 2. 세부 구현 사항에 독립적
일반적으로 개발자가 코드베이스에 가할 수 있는 변경은 두 가지 종류가 있다.

- **기능적 변화**
  - 이것은 코드가 외부로 보이는 동작을 수정한다. 예를 들어 새로운 기능 추가, 버그 수정, 에러 처리 등이 있다.
- **리팩터링**(refactoring)
  - 이것은 큰 함수를 작은 함수로 분할하거나 재사용하기 쉽도록 일부 유틸리티 코드를 다른 파일로 옮기는 등의 코드의 구조적 변화를 의미한다.
    리팩터링이 올바르게 수행되더라도 이론적으로는 코드의 외부에서 보이는 동작(또는 기능적 속성)이 변경되면 안 된다.

이 중 첫 번째(기능적 변화)는 코드를 사용하는 모든 사람에게 영향을 미치므로 이러한 종류의 변경을 가하기 전에 코드를 호출하는 쪽을 신중히 고려해야 한다.
기능적인 변경은 코드의 동작을 수정하기 때문에 테스트도 수정해야 할 것으로 기대하고 예상한다. 그렇지 않다면 아마도 원래 테스트가 충분히 이루어지지 않았을 수 있다.

두 번째(리팩터링) 경우에는 코드를 사용하는 사람에게 영향을 미치지 않아야 한다. 구현 세부 사항을 변경하고 있지만 다른 사용자가 주의해야 할 행동은 없다.
그러나 코드를 수정하는 것은 항상 위험하며 리팩터링도 다를 바 없다.
우리의 의도는 코드의 구조만 수정하는 것인데 그 과정에서 실수로 코드의 동작을 변경하지 않았다는 것을 어떻게 확실히 알 수 있을까?

이 질문에 대한 답을 얻기 위해 리팩터링을 하기로 결정하기 훨씬 전에 원래의 단위 테스트를 작성할 때 가능했던 두 가지 접근 방식을 고려해보자.
- 접근 방식 A
  - 테스트는 코드의 모든 동작을 확인할 뿐만 아니라 다양한 구현 세부 사항도 확인한다.
    프라이빗 함수를 테스트 코드에서 접근할 수 있도록 만들어 테스트하고, 프라이빗 멤버 변수 및 의존성을 직접 조작하여 상태를 시뮬레이션하며,
    코드가 실행된 후 다양한 멤버 변수의 상태를 검증한다.
- 접근 방식 B
  - 동작만 테스트할 뿐 구현 세부 사항은 확인하지 않는다. 코드의 공개 API를 사용하여 상태를 설정하고 할 수 있는 곳에서 동작을 확인한다.
    그리고 프라이빗 변수나 함수를 사용하여 어떠한 것도 조작하거나 검증하지 않는다.

이제 몇 달 후에 코드를 리팩터링하면 어떻게 되는지 생각해보자.
리팩터링을 올바르게 수행할 경우 구현 세부 정보만 변경되어야 하며 외부에서 볼 수 있는 동작에는 영향을 미치지 않아야 한다.
만약 외부에서 보이는 행동들이 영향을 받는다면, 리팩터링이 잘못된 것이다. 이 두 가지 서로 다른 테스트 방식을 사용한 경우 리팩터링으로 인해 어떤 결과가 발생하는지 생각해보자.

- 접근 방식 A
  - 리팩터링을 올바르게 수행했는지 여부와 관계없이 테스트가 실패하기 시작할 것이며 테스트를 다시 통과하려면 테스트 코드를 많이 변경해야 한다.
    다른 프라이빗 함수를 테스트하고, 다른 프라이빗 멤버 변수와 의존성으로 상태를 설정하고, 코드가 실행된 후 다른 멤버 변수를 확인해야 한다.
- 접근 방식 B
  - 리팩터링을 올바르게 수행했다면 테스트 코드를 수정할 필요 없이 테스트는 여전히 통과할 것이다. 만약 테스트가 실패한다면, 리팩터링이 잘못됐다는 것이 분명하다.
    왜냐하면 테스트 실패는 리팩터링하면서 부주의로 외부로 보이는 동작을 바꾼 것을 의미하기 때문이다.

접근 방식 A에서는 코드를 리팩터링할 때 코드의 동작을 바꾸는 실수를 하지 않았다고 확신하기 어렵다.
테스트의 실패가 코드의 동작을 바꾼 것 때문이라면 코드를 다시 수정해야 하고, 그렇지 않다면 내부 구현만 변경한 것이기 때문에 테스트 코드를 수정해야 하는데,
테스트 코드의 어느 부분에서 실패가 예상되는지 파악하기가 쉽지 않다.
접근 방식 B에서는 리팩터링에 대한 확신을 갖기가 매우 쉽다. 테스트가 여전히 통과된다면 리팩터링이 잘 된 것이고, 테스트가 실패한다면 코드의 동작을 변경한 실수를 범한 것이다.

#### [기능 변경과 리팩터링을 같이 하지 말라]
코드베이스를 변경할 때 일반적으로 기능만 변경하거나 리팩터링만 해야지 두 가지 작업을 동시에 수행하는 것은 좋지 않다.<br/>
리팩터링은 어떠한 동작도 변경하지 않지만, 기능 변경은 동작을 변경한다.
기능적 변화와 리팩터링을 동시에 하면 기능적 변화로 예상되는 동작의 변화와 리팩터링의 실수로 발생하는 동작의 변화를 구분하기 어려울 수 있다.
**보통 리팩터링을 한 다음 기능 변경을 따로 하는 것이 좋다.** 이렇게 하면 잠재적인 문제의 원인을 분리하기가 훨씬 더 쉬워진다.
<br/>
<br/>
코드는 자주 리팩터링된다. 성숙한 코드베이스에서는 리팩터링의 양이 작성된 새 코드의 양을 초과할 수 있으므로 리팩터링 시 코드가 훼손되지 않도록 하는 것이 가장 중요하다.
테스트가 구현 세부 정보에 의존하지 않으면 코드 리팩터링에 실수가 있었는지 확인해주는 테스트 결과를 신뢰할 수 있다.

## 3. 잘 설명되는 실패
앞서 몇 개의 하위 절에서 살펴본 것처럼 테스트의 주요 목적 중 하나는 미래의 훼손으로부터 코드를 보호하는 것이다.
일반적인 경우는 개발자가 변경한 코드로 인해 다른 사람이 작성한 코드가 동작을 하지 않는 것이다.
테스트는 실패하기 시작하고, 테스트 결과는 개발자에게 그들이 무언가를 고장 냈다는 것을 알린다. 개발자는 테스트 실패에 대한 자세한 내용을 살펴보고 무엇이 문제인지 알아낸다.
개발자는 그들이 무심코 망가뜨린 코드를 잘 모를 수 있기 때문에 테스트 실패가 무엇이 잘못됐는지 알려주지 않는다면 그것을 알아내기 위해 많은 시간을 낭비해야 한다.

테스트가 코드에서 동작하지 않는 부분을 명확하고 정확하게 설명하려면 문제가 발생했을 때 어떤 실패 메시지를 만들어낼지, 그리고 이것이 다른 개발자에게 유용할지 생각해볼 필요가 있다.
다음 그림은 테스트 실패 시 가능한 두 가지 실패 메시지를 보여준다. 첫 번째 메시지는 이벤트를 받는 것이 잘못되었지만 무엇이 정확히 잘못되었는지에 대한 정보를 전혀 제공하지 않는다.
반면에 두 번째 메시지는 무엇이 잘못되었는지에 대해 상당히 명확하게 설명해 주는데, 받은 이벤트가 시간 순서대로 되어 있지 않은 것이 문제라는 것을 메시지로부터 알 수 있다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/89ff65a2-64f2-4671-b43a-8a798ed1278c" width="500" height="400"/><br/>
- 단지 잘못됐다고만 알려주는 테스트보다 무엇이 잘못되었는지 명확하게 설명하는 테스트 실패가 훨씬 더 유용하다.

테스트 실패가 잘 설명되도록 하는 좋은 방법 중 하나는 하나의 테스트 케이스는 한 가지 사항만 검사하고 각 테스트 케이스에 대해 서술적인 이름을 사용하는 것이다.
이렇게 하면 한 번에 모든 것을 테스트하려고 하는 하나의 큰 테스트보다 각각의 특정 동작을 확인하기 위한 작은 테스트 케이스가 많이 만들어진다.
테스트가 실패할 때 실패한 케이스의 이름을 확인하면 어떤 동작이 작동하지 않는지 정확하게 알 수 있다.

## 4. 이해 가능한 테스트 코드
지금까지 테스트가 실패하면 원래의 코드가 작동하지 않는다는 것을 가정했다. 하지만 정확히 말하자면 이것은 사실이 아니다.
좀 더 정확하게는 테스트 실패는 코드가 다른 방식으로 동작한다는 것을 나타낼 수 있다.
그것이 다른 방식으로 동작한다는 사실이 실제로 코드가 작동하지 않는 것인지는 상황에 따르다.
예를 들어 다른 개발자는 새로운 요구 사항을 충족하기 위해 코드의 기능을 의도적으로 수정할 수 있다. 이 경우 동작의 변화는 의도적이다.

이러한 변경을 수행하는 개발자는 분명 주의할 테지만 열심히 작업하고 변경된 결과가 안전한지 확인한 후에는 새로운 기능을 반영하기 위해 테스트 코드도 수정해야 한다.
앞서 살펴본 것처럼 코드를 수정하는 것은 위험하며, 이는 테스트 코드에도 적용된다. 한 코드에 대해 세 가지 동작이 테스트된다고 가정해보자.
개발자가 이런 동작 중 하나만 의도적으로 변경할 경우 해당 동작에 대한 테스트 케이스만 변경하고 다른 두 가지 동작에 대한 테스트 케이스는 변경하지 않고 그대로 두는 것이 이상적이다.

개발자가 자신이 변경한 사항이 원하는 동작에만 영향을 미친다는 확신을 가지려면 테스트의 어느 부분에 영향을 미치고 있는지, 테스트 코드에 대한 수정이 필요한지 여부를 알 수 있어야 한다.
이를 위해서는 서로 다른 테스트 케이스가 무엇을 테스트하는지 그리고 어떻게 테스트하는지 이해하고 있어야 한다.

다음 장에서 살펴보겠지만 여기서 문제가 발생할 수 있는 가장 일반적인 두 가지 경우는 한 번에 너무 많은 것을 테스트하는 것과 너무 많은 공유 테스트 설정을 사용하는 것이다.
이 두 가지 모두 이해하기 어렵고 추론하기 어려운 테스트로 이어질 수 있다.
이 경우 개발자들이 특정 변경 사항이 안전한지 이해하는 데 어려움을 겪을 수 있기 때문에 코드 수정의 결과가 안전하지 않을 수 있다.

테스트 코드를 이해하기 쉽게 만들기 위해 노력해야 하는 또 다른 이유는 일부 개발자들이 테스트를 코드에 대한 일종의 사용 설명서로 사용하기 때문이다.
특정 코드를 어떻게 사용하는지, 혹은 어떤 기능을 제공하는지 궁금하다면  단위 테스트를 통해 알아보는 것도 좋은 방법이다.
테스트 코드가 이해하기 어렵다면 사용 설명서로 유용하게 사용될 수 없을 것이다.

## 5. 쉽고 빠른 실행
대부분의 단위 테스트는 꽤 자주 실행된다. 단위 테스트의 중요한 기능 중 하나는 잘못된 코드가 코드베이스에 병합되는 것을 방지하는 것이다.
따라서 많은 코드베이스에서 관련 테스트를 통과해야만 병합이 가능한 병합 전 검사를 수행한다.
단위 테스트를 실행하는 데 한 시간이 걸린다면 코드 변경 병합 요청이 작거나 사소한 것과 상관없이 최소 한 시간이 걸리기 때문에 모든 개발자의 속도가 느려진다.
코드베이스에 변경 사항을 병합하기 전에 실행할 뿐만 아니라, 개발자는 코드를 개발하는 동안 단위 테스트를 수없이 많이 실행하기 때문에
느린 단위 테스트는 개발자의 작업 속도를 느리게 만든다.

테스트를 빠르고 쉽게 유지해야 하는 또 다른 이유는 개발자가 실제로 테스트를 할 수 있는 기회를 극대화하기 위함이다.
테스트가 느리면 테스트가 힘든 작업이 되고, 테스트가 힘들면 하고 싶지 않은 마음이 든다.
이것은 아마도 자존심이 강한 많은 개발자들이 흔쾌히 인정하려 들지 않겠지만, 경험에 비추어보면 현실에서는 그런 것 같다.
테스트를 가능한 쉽고 빠르게 수행할 수 있으면 개발자는 더 효율적으로 작업할 수 있고, 테스트 역시 더 광범위하고 철저해진다.
