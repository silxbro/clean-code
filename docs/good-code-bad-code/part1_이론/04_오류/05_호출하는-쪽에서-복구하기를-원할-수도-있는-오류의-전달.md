# 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달
<br/>

호출하는 쪽에서 복구하기를 원할 수도 있는 오류를 전달하고자 할 때,
이에 대한 모범 사례와 관련해 소프트웨어 엔지니어(그리고 프로그래밍 언어 설계자) 사이에서 일치된 의견이 없으므로 흥미로운 주제다.
이와 관련해 비검사 예외와 명시적 오류 전달 기법(검사 예외, 널 안전성, 옵셔널 유형, 리절트 유형 등) 중 어느 것을 사용해야 하는지에 대한 논쟁이 있다.
이 두 가지 측면 모두 타당한 주장과 반론이 있으며, 이 절에서 이에 관해 요약해보겠다.

그 전에 먼저 기억해야 할 점은 여러분과 여러분의 팀이 동의한 철학이 다른 어떤 주장보다도 중요하다는 점이다.
최악의 상황은 팀의 절반은 오류 전달 및 처리에 관해 한쪽의 관행을 따르는 코드를 작성하고, 나머지 절반은 완전히 다른 관행을 따르는 것이다.
이런 경우에는 코드가 서로 상호작용해야할 때마다 악몽과 같은 상황을 맞이할 것이다.

제시된 바와 같이 다음에 소개하는 주장들은 모 아니면 도인 것처럼 들릴 수 있지만,
다른 개발자와 이에 관해 이야기를 나눈다면 오류 전달과 처리에 관한 그들의 의견 차이가 아주 미세하다는 것을 알 수 있을 것이다.

#### [구현 세부 사항 노출]
호출하는 쪽에서 복구하기를 원하는 오류에 대한 또 다른 고려 사항은 호출하는 쪽에서 전달받은 오류를 처리하기 위해 굳이 호출하는 코드의 구현 세부 사항을 알 필요가 없다는 것이다.
(8장(8.6, 8.7): 모듈화의 맥락)

## 1. 비검사 예외를 사용해야 한다는 주장
잠재적으로 복구할 수 있는 오류에도 불구하고 비검사 예외를 사용하는 것이 더 나은 이유에 대한 일반적인 주장은 다음과 같다.

### 코드 구조 개선
대부분의 오류 처리가 코드의 상위 계층에서 이루어질 수 있기 때문에 (명시적인 기술을 사용하는 대신) 비검사 예외를 발생시키면 코드 구조를 개선할 수 있다고 주장하는 개발자들이 있다.
오류가 높은 계층까지 거슬러 올라오면서 전달되고, 그 사이에 있는 코드는 오류 처리를 할 필요가 없다. 다음 그림은 이것을 보여준다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/daecc723-e70d-4a00-8041-369377ebffc8" width="500" height="300"/><br/>
- 대부분의 오류 처리가 몇 개의 계층에서만 이뤄지기 때문에 비검사 예외를 사용하면 코드 구조를 개선할 수 있다고 주장하는 개발자들이 있다.

중간에 있는 계층은 (특정 작업을 다시 시도하는 등) 원한다면 예외 중 일부를 처리할 수 있지만, 그렇지 않으면 오류가 최상위 오류 처리 계층으로 전달된다.
사용자 응용 프로그램이라면 오류 처리 계층은 오류 메시지를 UI에 표시할 수 있다. 서버나 백엔드라면 오류 메시지가 기록될 수 있다.
이 접근법의 핵심 장점은 오류를 처리하는 로직이 코드 전체에 퍼지지 않고 별도로 몇 개의 계층에만 있다는 점이다.

### 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함
일부에서는 개발자들이 너무 많은 명시적 오류 전달(반환 유형 및 검사 예외)을 접하면 결국 잘못된 일을 한다고 주장한다.
예를 들어 예외를 포착하고도 무시한다거나, 널이 가능한 유형을 확인도 하지 않고 널이 불가능한 유형으로 반환을 하는 것이다.

이를 설명하기 위해 예제 4.28과 같은 코드가 코드베이스 어딘가에 존재한다고 상상해보자.
이 예제 코드는 온도를 데이터 로거에 기록하고, 이것은 다시 InMemoryDataStore를 사용하여 로그 데이터를 저장한다.
이 코드는 오류를 일으킬 수 있는 것이 없기 때문에 오류 전달이나 처리 기술이 필요하지 않다.

#### [예제 4.28] 오류가 없는 초기 코드
```java
class TemperatureLogger {
  private final Thermometer thermometer;
  private final DataLogger dataLogger;
  ...

  void logCurrentTemperature() {
    dataLogger.logDataPoint(
      Instant.now(),
      thermometer.getTemperature());
  }
}

class DataLogger {
  private final InMemoryDataStore dataStore;
  ...

  void logDataPoint(Instant time, Double value) {
    dataStore.store(new DataPoint(time.toMillis(), value));
  }
}
```
메모리에 값을 저장하는 대신 디스크에 저장하여 로그 데이터를 영구적으로 유지할 수 있도록 DataLogger 클래스를 수정하는 요청을 개발자가 받았다고 가정해보자.
개발자는 InMemoryDataStore 클래스를 DiskDataStore 클래스로 교환한다. 이때 디스크에 쓰기가 실패할 수 있으므로 오류가 발생할 수 있다.
명시적인 오류 신호 기법을 사용하는 경우 오류를 처리하거나 호출 체인을 따라 이전 호출자에게 명시적으로 오류를 전달해야 한다.

이 시나리오에서는 DiskDataStore.store()에서 검사 예외 IOException를 발생시키는 것을 통해 이 방식을 보여주겠지만, 원리적으로는 다른 명시적 오류 신호 기법도 동일하다.
IOException은 검사 예외이기 때문에 예외 처리를 하거나 그렇지 않으면 DataLogger.logDataPoint() 함수의 시그니처에 표시해야 한다.
DataLogger.logDataPoint() 함수 내에서 이러한 오류를 처리할 수 있는 합리적인 방법은 없지만, 함수 시그니처에 추가하면 이 함수를 호출하는 모든 코드를 수정하고
그보다 더 위 계층의 코드까지도 수정해야 할 수도 있다.
이렇게 할 경우 작업의 양이 너무 많기 때문에 개발자는 여기에서 오류를 숨기고 아래 예제와 같은 코드를 작성할지도 모른다.

#### [예제 4.29] 검사 예외 숨기기
```java
class DataLogger {
  private final DiskDataStore dataStore;
  ...

  void logDataPoint(Instant time, Double value) {
    try {
      dataStore.store(new DataPoint(time.toMillis(), value));
    } catch (IOException e) {}  // IOException 오류가 호출자에게 숨겨진다.
  }
}
```
이 장에서 앞서 언급한 바와 같이, 오류를 숨기는 것은 결코 좋은 생각이 아니다. 이제 DataLogger.logDataPoint() 함수는 자신이 수행해야 할 기능을 항상 수행하지는 않게끔 변경됐다.
이 함수를 호출할 때 데이터가 저장되지 않을 수도 있지만, 호출하는 쪽에서는 이 사실을 알지 못한다.
명시적인 오류 전달 방식을 사용하면 코드의 계층을 올라가면서 오류를 반복적으로 전달하고 이를 처리하는 일련의 작업이 필요한데,
이런 번거로운 작업 대신 개발자는 편의를 도모하고 잘못된 작업을 하고 싶은 마음이 들 수 있다.
비검사 예외의 사용에 찬성하기 위해 자주 표현되는 주장 중 하나가 이 문제에 대해 실용적으로 접근해야 한다는 주장이다.

## 2. 명시적 기법을 사용해야 한다는 주장
잠재적으로 복구할 수 있는 오류에 대해 명시적인 오류 전달 기술을 사용하는 것이 더 나은 이유에 대한 주장은 일반적으로 다음과 같다.

### 매끄러운 오류 처리
비검사 예외를 사용한다면 모든 오류를 매끄럽게 처리할 수 있는 단일 계층을 갖기가 어렵다.
예를 들어 사용자 입력이 잘못되면 해당 입력 필드 바로 옆에 오류 메시지를 보여주는 것이 타당하다.
입력을 처리하는 코드를 작성하는 엔지니어가 오류 시나리오를 알지 못하고 더 높은 수준으로 전달되도록 내버려 둔다면, 이는 사용자 친화적이지 않은 오류 메시지를 UI에 표시할 수 있다.

(반환 유형이나 검사 예외를 사용하여) 호출하는 쪽에 잠재적 오류를 강제적으로 인식하도록 하면 이러한 오류를 좀 더 매끄럽게 처리할 가능성이 커진다.
암시적인 방식을 사용하면 개발자는 오류가 일어날 수 있다는 것을 알지 못하는데 하물며 그것을 어떻게 처리할 수 있을까?

### 실수로 오류를 무시할 수 없다
어떤 호출자의 경우에는 실제로 오류를 처리해야 하는 경우가 있을 수 있다.
비검사 예외가 사용되면 적극적인 의사 결정이 들어갈 여지는 줄어들고 대신 기본적으로 잘못된 일(오류를 처리하지 않는 일)이 일어나기 쉽다.
이는 개발자(및 코드 검토자)가 특정 오류가 발생할 수 있다는 사실을 완전히 알지 못하기 때문이다.

만약 반환 타입이나 검사 예외와 같이 보다 더 명시적인 오류 전달 방식을 사용한다 해도, 개발자들은 여전히 잘못된 일을 할 수 있다(가령 예외를 포착하지만 무시해버린다).
하지만 이렇게 하는 것은 적극적인 노력이 필요하고 눈에 띄는 위반 사항이다. 따라서 이런 상황은 코드 검수 시 명확하게 드러나게 되고, 이런 잘못된 코드를 차단할 가능성이 커진다.
좀 더 명확한 오류 전달 방식을 사용하면 잘못된 일이 기본적으로 혹은 실수로 인해 일어나지 않는다.

다음 그림은 비검사 예외와 검사 예외를 사용하는 경우 변경된 코드가 검토자에게 어떻게 보이는지를 대조해서 보여준다.
비검사 예외를 사용할 경우 코드에서 나쁜 일이 발생한다는 사실이 분명하게 드러나지 않지만, 검사 예외를 사용할 경우 이 점이 아주 명백하게 드러난다.
다른 명시적 오류 전달 기법(예: @CheckReturnValue 애너테이션으로 강제되는 결과 반환 유형)은 개발자의 위반 사항이 코드 변경 시에도 이와 비슷하게 분명하게 나타나도록 해준다.

#### [비검사/검사 예외를 사용할 때의 코드 변경]
```java
class TemperatureLogger {
  private final Thermometer thermometer;
  private final DataLogger dataLogger;
  ...

  void startLogging() {
    Timer.schedule(
        logCurrentTemperature,
        Duration.ofMinutes(1));
    /**
     * Timer.schedule()은 새로운 스레드를 시작하기 때문에
     * 스케줄된 코드에서 발생하는 어떠한 예외도 이 계층 이상으로 올라가지는 않는다.
     */
  }

  void logCurrentTemperature() {

  // 비검사 예외를 사용할 때의 코드 변경
  /**
   * UncheckedIOException이 처리되지 않았지만 새로운 코드는 명백히 잘못된 코드가 아니다.
   */
    dataLogger.logDataPoint(
        Instant.now(),
        thermometer.getTemperature());
    

  // 검사 예외를 사용할 때의 코드 변경
  /**
   * IOException이 적절하게 처리되지 않았지만
   * 새로운 코드로부터 이 사실이 명백하게 보이고 코드를 검수할 때 쉽게 눈에 띈다.
   */
    try {
      dataLogger.logDataPoint(
        Instant.now(),
        thermometer.getTemperature());
    } catch (IOException e) {
      logError(e);
    }

  }
}

class DataLogger {
  ...

  // 비검사 예외를 사용할 때의 코드 변경
  /**
   * @throws UncheckedIOException if
   * saving data point fails.
   */
  void logDataPoint(
      Instant time,
      Double value) { ... }

  // 검사 예외를 사용할 때의 코드 변경
  void logDataPoint(
      Instant time,
      Double value) throws IOException
      { ... }
}
```
- 명시적 오류 전달 기법을 사용할 때, 오류를 적절히 처리하지 않으면 종종 고의적이고 노골적인 위반이 발생할 수 있다.<br/>
  반대로 비검사 예외를 사용하면 오류가 제대로 처리되지 않았다는 사실을 코드에서 알 수 없다.

### 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함
개발자들이 오류 처리를 너무 많이 해야 되서 잘못되게 처리한다는 주장은 비검사 예외의 사용을 반박하는 것에도 적용할 수 있다.
비검사 예외가 코드베이스 전반에 걸쳐 제대로 문서화된다는 보장이 없고, 개인적인 경험에 비추어 보면 문서화되지 않는 경우가 많다.
이는 종종 어떤 코드가 어떤 예외를 발생시킬 것인지 확실하게 알지 못한다는 것을 의미하고, 이로 인해 예외를 처리하는 것이 당황스러운 두더지 잡기 게임이 될 수 있다.

예제 4.30 코드는 데이터 파일이 유효한지 확인하는 함수를 보여준다. 이 작업을 수행하기 위해 파일이 잘못되었음을 나타내는 예외가 발생하는지 확인한다.
DataFile.parse()는 여러 가지의 비검사 예외를 발생시킨다. isDataFileValid() 함수의 작성자는 아래 코드에서 볼 수 있듯이 이 중에서 세가지의 비검사 예외를 처리한다.

#### [예제 4.30] 여러 유형의 비검사 예외 처리
```java
Boolean isDataFileValid(byte[] fileContents) {
  try {
    DataFile.parse(fileContents);  // 문서화되지 않고 비검사 예외를 여러 개 발생시킬 수 있다.
    return true;
  } catch (InvalidEncodingException |
           ParseException |
           UnrecognizedDataKeyException e) {  // 세 가지의 비검사 예외를 처리한다.
    return false;
  }
}
```
코드를 배포한 후 isDataFileValid() 함수의 작성자는 시스템이 자주 작동을 멈춘다는 보고를 접한다.
그 이유를 조사해보니 DataRangeException이라는 또 다른 종류의 문서화되지 않은 비검사 예외로 인해 장애가 발생한다는 사실을 알게 된다.
이 시점에서 코드 작성자는 이러한 모든 비검사 예외들을 처리하기 위해 두더지 잡기 게임을 하는 것에 지쳐서 모든 종류의 예외를 나타내는 일반적인 예외로 처리하고 말기로
결정할 수 있다. 다음 예제는 이 상황을 보여준다.

#### [예제 4.31] 모든 유형의 예외 처리
```java
Boolean isDataFileValid(byte[] fileContents) {
  try {
    DataFile.parse(fileContents);
    return true;
  } catch (Exception e) {  // 모든 종류의 예외를 처리한다.
    return false;
  }
}
```
이 코드에서와 같이 모든 예외를 다 아우르는 예외를 처리하는 것은 바람직하지 않다.
이렇게 하면 프로그램이 현실적으로 복구할 수 없는 많은 오류를 포함하여 거의 모든 유형의 오류가 숨겨진다. 어쩌면 심각한 프로그래밍 오류가 숨겨질 수도 있다.
이것은 DataFile.parse() 함수의 버그일 수도 있고, ClassNotFoundException과 같은 심각한 소프트웨어 구성 오류일 수도 있다.
어느 쪽이든 이러한 프로그래밍 오류는 이제 전혀 눈에 띄지 않을 것이고, 소프트웨어는 조용하고 이상한 방식으로 실패할 수 있다.

예제 4.31의 코드와 같은 위반 사항은 상당히 노골적이므로 코드 검토 중에 발견되고 수정되어야 한다.
그러나 코드 검토 프로세스가 이와 같은 위반을 탐지할 만큼 충분히 강력하지 않다면, 비검사 예외를 사용하든 명시적인 오류 전달 처리 방식을 사용하든
어느 경우라도 문제가 있을 수 있다는 것을 알아야 한다. 진짜 문제는 개발자들이 일을 허술하게 하고 이것을 걸러낼 강력한 과정이 없다는 점이다.

#### [표준 예외 유형 고수]
이러한 두더지 잡기 게임식의 예외 처리를 피하기 위해 비검사 예외를 사용하는 개발자가 선호하는 방식은 ArgumentException이나 StateException과 같은
표준 예외 유형 혹은 그것들의 서브 클래스를 사용하는 것이다.
다른 개발자들은 이런 표준 예외들이 발생할 것이라고 예측하고 이것들을 적절하게 처리함으로써 신경 써야 할 예외의 종류가 줄어든다.

하지만 서로 다른 오류 시나리오를 구별하는 기능을 제한할 수 있다는 단점이 있다.
StateException을 초래한 원인이 여러 가지인데 그중 어떤 것은 호출자가 복구하려는 것일 수도 있지만, 다른 것은 그렇지 않을 수 있다.
지금까지 다룬 내용을 통해 알 수 있듯이 오류 전달과 처리에 대한 내용은 완전무결한 과학의 영역이 아니고 어떤 방법을 사용하든지 고려해야 할 장단점이 있다.

## 3. 필자의 의견: 명시적 방식을 사용하라
호출하는 쪽에서 복구하기를 원할 수도 있는 오류에 대해 비검사 예외를 사용하지 않는 것이 최상이라는 것이 필자의 의견이다.
필자의 경험상 비검사 예외의 사용은 코드베이스 전반에 걸쳐 완전히 문서화되는 경우가 매우 드물며,
이것이 의미하는 바는 해당 함수에 대해 발생 가능한 오류와 이에 대한 처리를 어떻게 해야 하는지 개발자가 확실하게 알기란 거의 불가능하다는 것이다.

호출하는 쪽에서 미리 알고 있었더라면 복구하기를 원할 수도 있는 오류에 대해 비검사 예외를 발생하고 이를 문서화하지도 않은 채 사용하는 경우
너무 많은 버그와 작동 실패가 일어나는 것을 경험했다. 따라서 호출하는 쪽에서 복구하기를 원할 가능성이 있다면 명시적 오류 전달 방식을 사용하는 것을 개인적으로 선호한다.

이 절에서 이미 논의한 바와 같이 이 접근 방식에 몇 가지 단점이 있지만, 개인적인 경험에 비추어보면 이러한 종류의 오류에 대해 비검사 예외를 사용하면 
오히려 심각한 문제가 더 많았다. 앞서 언급했듯이 더 바람직하지 않은 상황은 팀 내에서 각자 개발자들이 서로 다른 접근 방식을 사용하는 것이다.
