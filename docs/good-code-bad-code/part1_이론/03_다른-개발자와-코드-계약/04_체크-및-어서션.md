# 체크 및 어서션
<br/>

컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다.
이 방법은 일반적으로 컴파일 타임 확인만큼 강력하지 않은데, 왜냐하면 코드 계약 위반의 발견이 코드를 실행하는 동안 발생하는 문제에 대한 테스트(또는 사용자)에 의존하기 때문이다.
이는 애당초 계약 위반을 논리적으로 불가능하게 만드는 컴파일 타임 확인과는 대조적이다.

그럼에도 불구하고 컴파일러를 사용하여 계약을 강제할 수 있는 실질적인 방법이 없는 상황이 더러 있다.
이러한 경우 런타임 검사를 통해 계약을 확인하는 것이 아예 계약을 확인하지 않는 것보다 낫다.
<br/>

## 1. 체크
코드 계약 조건을 확인하기 위한 일반적인 방법은 체크(check)를 사용하는 것이다.
이것은 코드 계약이 준수되었는지(입력 매개변수에 대한 제약 조건 또는 수행해야 할 설정에 대한 제약 등) 확인하기 위한 추가적인 로직이며,
준수되지 않을 경우 체크는 실패를 유발하는 오류(또는 이와 유사한 것)를 생성하는데, 이 실패는 명백해서 놓치고 넘어가는 것이 불가능하다.
(체크는 **신속한 실패**(falling fast)와 밀접한 관련이 있다.)

체크는 시행 중인 계약 조건에 따라 다음과 같은 범주로 구분된다.
- **전제 조건 검사**
  - 예를 들어 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우
- **사후 상태 검사**
  - 예를 들어 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우

UserSettings 클래스가 잘못 설정되는 것을 아예 불가능하게 함으로써 오류를 줄일 수 있음을 앞서 살펴봤다.
다른 방법은 전제 조건 검사를 사용하는 것이다. 이것을 사용해 클래스를 작성한다면 코드는 다음 예제와 같다.

#### [예제 3.4] 계약 시행을 위한 체크 사용
```java
class UserSettings {

  UserSettings() { ... }

// 이 함수를 사용해 설정이 올바르게 로드되기 전까지는 다른 어떤 함수도 호출해서는 안 된다.
// 설정이 성공적으로 로드되면 참을 반환한다.
  bool loadSettings(File location) { ... }

// init()은 다른 함수 호출 이전에 호출해야 하지만
// loadSettings() 함수 호출 이후에만 호출해야 한다.
  void init() {
    if (!haveSettingsBeenLoaded()) {
      throw new StateException("Settings not loaded");       // 클래스가 유효하지 않은 방법으로 사용되면 예외가 발생한다.
    }
    ...
  }

// 사용자가 선택한 UI의 색상을 반환한다.
// 선택된 색상이 없으면 널을 반환한다.
  Color? getUiColor() {
    if (!hasBeenInitialized()) {
      throw new StateException("Settings not initialized");  // 클래스가 유효하지 않은 방법으로 사용되면 예외가 발생한다.
    }
    ...
  }
}
```
이 코드는 버그가 아무도 모르게 발생하는 것을 방지함으로써 세부 조항이 많았던 원래의 코드를 개선하는데, 설정이 성공적으로 로드되지 않은 경우에는 로드 실패가 발생한다.
하지만 이것은 오용을 아예 불가능하게 만든 해결책보다는 이상적이지는 않다.

### [프로그래밍 언어에서 체크]
예제 3.4는 `StateException`을 사용하여 사용자 맞춤형으로 전제 조건 검사를 구현한다.
일부 언어에서는 체크를 언어 자체에서 제공하기 때문에 구문적으로 더 낫지만, 체크를 제공하지 않는 다른 언어는 좀 더 수동적인 접근 방식이나 타사 라이브러리를 사용해야 한다.
체크를 사용하기로 결정했다면 사용하는 언어로 체크를 구현하는 가장 좋은 방법을 찾아봐야 한다.

체크를 사용할 때 기대하는 것은 코드가 오용되면 고객에게 배포되거나 실제 프로덕션에서 서비스되기 전에 개발 단계나 테스트 단계에서 발견되고 수정되는 것이다.
이것은 프로그램이 아무도 눈치채지 못하게 유효하지 못한 상태로 들어가 이상한 버그가 발견되지만, 처음에는 명백하게 파악되지 않는 상황보다는 낫다.
그러나 체크의 효과가 보장되는 것은 아니다.
- 테스트하기가 불분명한 상황에서만 확인 중인 조건이 위반된다면(또는 퍼즈 테스트가 시뮬레이션 되지 않는 경우),
  코드가 배포되고 사용자가 사용하기 전까지 버그가 노출되지 않을 수 있다.
- 체크가 잘 작동해서 실패가 명백함에도 불구하고 아무도 알아차리지 못할 위험이 있다.
  예외가 일어나더라도 시스템이 작동을 완전히 멈추지 않도록 하기 위해 프로그램의 상위 수준에서 예외가 처리되고 오류의 자세한 사항이 로그에 기록될 수 있다.
  개발자가 이 로그들을 신경쓰지 않는다면, 오류가 발생할 때 아무도 알아차리지 못한다. 이런 일이 일어나면 개발과 관련해 팀의 실행지침(또는 예외 처리)에 심각한 문제가 있음을 시사한다.
  불행히도 이런 문제는 필요 이상으로 자주 발생한다.

경우에 따라 코드 계약에서 세부 조항을 피할 수 없으며, 이때는 계약이 준수되는지 확인하기 위해 체크를 추가하는 것이 좋다.
하지만 가능하다면 처음부터 세부 조항은 피하는 것이 바람직하다. 코드에 체크가 많이 있으면 세부 조항을 없애는 것에 대해 고려해봐야 한다는 신호일지도 모른다.

#### [퍼즈 테스트]
퍼즈 테스트(fuzz test)는 코드나 소프트웨어의 버그나 잘못된 설정을 드러낼 수 있는 입력값을 생성해 테스트를 수행하는 테스트의 한 종류다.

예를 들어 사용자가 제공한 문자열 값을 입력으로 사용하는 소프트웨어가 있다면 퍼즈 테스트는 많은 임의의 문자열을 생성하고 이 값들을 입력으로 사용해 장애나 예외가 발생하는지
확인할 수 있다. 예를 들어 특정 문자가 포함된 문자열이 프로그램의 작동을 멈추게 한다면, 퍼즈 테스트를 통해 이를 발견할 수 있기를 기대한다.

퍼즈 테스트를 사용하는 경우, 체크(또는 어서션)를 함께 사용하면 잘못된 설정이나 버그를 발견할 가능성을 높이는 데 도움이 된다.
왜냐하면 퍼즈 테스트는 오류나 예외 발생에 의존하며 이것만으로는 단순히 이상한 동작을 초래하는 미묘한 버그를 발견할 수 없기 때문이다.

## 2. 어서션
많은 언어에서 **어서션**(assertion)을 언어 차원에서 지원한다. 어서션은 코드 계약을 준수하도록 강제하기 위한 방법이라는 점에서 체크와 매우 유사하다.
코드가 개발 모드에서 컴파일 되거나 테스트가 실행될 때, 어서션은 체크와 거의 같은 방식으로 동작한다. 조건이 위반되면 오류가 명백하게 보이거나 예외가 발생한다.
어서션과 체크 사이의 주요 차이점은 배포를 위해 빌드할 때 **어서션은 보통 컴파일에서 제외**된다는 점이며,
이는 코드가 실제 서비스 환경에서 사용될 때 실패를 명백하게 보여주지 않는다는 것을 의미한다. 코드를 배포할 때 컴파일하지 않는 이유는 다음과 같다.
- 성능 향상을 위해
  - 조건이 위반되는지 확인하려면 CPU 사이클이 필요하다. 코드에서 어서션이 많으면 소프트웨어의 전반적인 성능이 눈에 띄게 저하될 수 있다.
- 코드 오류 발생률을 낮추기 위해
  - 이것이 유효한 동기인지 아닌지는 특정 응용 프로그램에 달려 있다.
    이로 인해 버그가 눈에 띄지 않을 가능성이 증가하지만 버그 발생 가능성 방지보다 고가용성이 더 중요한 시스템이라면 배포 시에 컴파일에서 제외하는 것은 적절한 절충이 될 수 있다.

코드의 배포를 위한 빌드에서도 어서션을 사용할 수 있는 방법이 있으며 많은 개발팀이 이렇게 한다.
이 경우 어서션은 체크와 다르지 않고, 다만 어떤 종류의 오류나 예외를 발생시킬 수 있는지에 대한 일부 세부 사항이 조금 다를 뿐이다.

UserSettings 클래스의 작성자가 체크 대신 어서션을 사용한다면 getUiColor() 함수는 다음 예제 코드와 같다.
#### [예제 3.5] 계약 시행을 위한 어서션 사용
```java
class UserSettings {
  ...

// 사용자가 선택한 UI의 색상을 반환한다.
// 선택한 색상이 없으면 널을 반환한다.
  Color? getUiColor() {
    assert(hasBeenInitialized(), "UserSettings가 초기화되지 않음"); / * 클래스가 유효하지 않은 방식으로 사용되면 
    ...                                                              * 어서션은 에러나 예외를 발생한다.
  }                                                                  * /                                                                                                                                                                                                                                                                                                                  *
}
체크에 대해 언급했던 사항은 어서션에도 해당된다. 코드 계약에 세부 조항이 있을 때 어서션을 사용하면 좋다. 하지만 애초에 세부 조항을 피하는 것이 더 바람직하다.
