# 견고성 vs 실패
<br/>

오류가 발생할 때, 다음 중 하나를 선택해야 한다.
- 실패, 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다.
- 오류를 처리하고 계속 진행한다.

오류가 있더라도 처리하고 계속 진행하면 더 견고한 코드라고 볼 수 있지만, 오류가 감지되지 않고 이상한 일이 발생하기 시작한다는 의미도 될 수 있다.
이 절에서는 견고성보다는 실패가 많은 경우에 있어 최선인 이유와 적절한 수준의 로직에서 견고성도 가질 수 있는 방법에 대해 설명한다.
<br/>

## 1. 신속하게 실패하라
신속하게 실패하기(falling fast)는 **가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것**이다.
복구할 수 있는 오류의 경우 호출하는 쪽에서 오류로부터 훌륭하고 안전하게 복구할 수 있는 기회를 최대한으로 제공하고,
복구할 수 없는 오류의 경우 개발자가 문제를 신속하게 파악하고 해결할 수 있는 기회를 최대한 제공한다.
두 경우 모두 소프트웨어가 의도치 않게 잠재적으로 위험한 상태가 되는 것을 방지한다.

이에 대한 일반적인 예는 잘못된 인수로 함수를 호출하는 경우다.
실패의 신속한 표시는 그 함수가 잘못된 입력과 함께 호출되는 즉시 오류를 발생시키는 것을 의미하며,
이는 잘못된 값임에도 불구하고 계속 실행해 코드의 다른 곳에서 문제를 일으키는 상황과는 반대된다.

다음 그림은 코드가 신속하게 실패하지 않을 경우 발생할 수 있는 상황을 보여준다.
오류가 실제 발생한 위치로부터 멀리 떨어진 곳에서 나타나고, 오류를 발견하기 위해 역방향으로 코드를 찾는 노력을 상당히 많이 기울여야 한다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/7fbaf3d9-6d50-472a-a094-2d0da13122ae" width="500" height="280"/><br/>
- 오류가 발생했을 때 신속하게 실패하지 않으면, 오류는 실제 위치에서 멀리 떨어진 코드에서 나타날 수 있다.
  이렇게 되면 문제를 추적하고 해결하기 위해 상당한 노력이 필요할 수 있다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/96809f0d-9073-4d84-9882-f35319c8038f" width="500" height="160"/><br/>
- 오류가 발생했을 때 코드가 신속하게 실패하면, 대개의 경우 오류의 정확한 위치가 즉시 확인된다.

이와는 대조적으로 위 그림은 신속하게 실패하면 상황을 상당히 개선할 수 있음을 보여준다.
실패가 신속하게 이뤄지면, 오류는 실제 위치 근처에서 나타나며 스택 트레이스는 종종 해당 오류의 위치에 대한 정확한 코드 위치를 제공한다.

이렇게 발생하자마자 바로 실패나 오류를 보여주지 않으면 문제가 발생할 때 디버그하기 어려울 뿐만 아니라, 코드가 제대로 작동하지 않거나 잠재적으로 문제를 일으킬 수 있다.
예를 들어 손상된 데이터가 데이터베이스에 저장되고 있음에도 불구하고 버그는 몇 달 후에야 발견될 수 있으며, 이 버그로 인해 이미 많은 중요한 데이터가 영구히 파괴됐을 수도 있다.

## 2. 요란하게 실패하라
프로그램이 복구할 수 없는 오류가 발생하면 프로그래밍 오류나 개발자의 실수로 인한 버그일 가능성이 크다.
누구나 소프트웨어에서 이런 버그가 일어나지 않기를 원하고, 일어나면 곧바로 버그를 고치기를 바라지만, 버그가 있다는 사실을 알지 못하면 고칠 수 있는 방법이 없다.

요란한 실패는 간단히 말하자면 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것이다.
이를 위한 가장 명백한(그리고 강압적인) 방법은 **예외**(또는 이와 유사한 것)를 발생해 프로그램이 중단되게 하는 것이다.
다른 방법은 오류 메시지를 기록하는 것인데 개발자가 얼마나 부지런하게 로그를 확인하는지, 혹은 로그에 방해되는 다른 메시지가 얼마나 있는지에 따라 오류 메시지가 무시될 수도 있다.
코드가 사용자의 장치에서 실행 중인 경우 서버에 오류 메시지를 보내 발생한 일을 기록할 수 있다(물론 사용자에게 승인을 받았을 경우).

코드가 실패할 때 신속하고, 요란하게 오류를 나타내면 개발 도중이나 테스트하는 동안에 버그가 발견될 가능성이 크다.
그렇지 않더라도 배포된 후에 오류 보고를 보기 시작할 것이고 보고 내용으로부터 버그가 발생한 위치를 정확히 알 수 있는 이점이 있다.

## 3. 복구 가능성의 범위
복구할 수 있는 또는 복구할 수 없는 범위는 달라질 수 있다.
예를 들어 클라이언트의 요청을 처리하는 서버 내에서 실행되는 코드를 작성하는 경우 개별 요청을 처리하는 도중 버그가 있는 코드 경로를 실행해 오류가 일어날 수 있다.
그 요청을 처리하는 범위 내에서 복구할 수 있는 합리적인 방법은 없지만, 시스템 전체가 작동을 멈추는 것은 막을 수 있다.
이 경우에 오류는 해당 요청 범위 내에서 복구할 수 없지만, 서버 전체적으로는 복구할 수 있다.

일반적으로 소프트웨어를 견고하게 작성하는 것이 좋다. 한 번의 잘못된 요청으로 인해 전체 서버의 동작이 멈추는 것은 바람직하지 않다.
그러나 오류를 알아차리지 못한 채 시스템이 계속 동작하지 않도록 하는 것 또한 중요하기 때문에 코드가 요란하게 실패해야 한다. 이 두 목표는 양립하지 못할 때가 많다.
가장 요란스럽게 실패하는 것은 프로그램이 멈추도록 하는 것이지만, 이것은 분명 소프트웨어를 견고하지 못하게 만든다.

이에 대한 해결책은 프로그래밍 오류가 발견되면 개발자가 이를 알아차릴 수 있도록 프로그래밍 오류를 기록하고 모니터링하는 것이다.
상세 오류 정보를 기록하여 개발자가 발생한 일을 디버그할 수 있게 해주고, 오류 발생률이 너무 높아지면 개발자에게 알림 메시지를 보내는 것이 이에 해당한다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/43281bec-9826-4fb0-ac02-a2c4ed539f4f" width="500" height="330"/><br/>
- 단일 요청을 처리할 때 서버에서 프로그래밍 오류가 발생할 수 있다. 요청은 독립 이벤트이므로 이 경우 전체 서버가 멈추지 않는 것이 최상이다.
  이 오류는 단일 요청 범위 내에서는 복구할 수 없지만, 서버 차원에서는 전체적으로 복구할 수 있다.

#### [서버 프레임워크]
대부분의 서버 프레임워크에는 개별 요청에 대한 오류를 격리하고 특정 유형의 오류를 다른 오류 응답 및 처리에 매핑할 수 있는 기능이 내장되어 있다.
따라서 개발자가 직접 try-catch 문장을 작성해야 할 가능성은 작지만, 개념적으로 이와 유사한 일이 서버 프레임워크 내부에서 일어난다.
<br/>
<br/>
프로그램의 더 높은 계층으로 신호를 보내는 대신 모든 유형의 오류를 기록하는 것은 극도로 주의해야 한다. 프로그램에는 오류를 로그로 기록하기에 적당한 장소가 있다.
예를 들어 높은 계층에 있는 코드의 진입점이나 프로그램의 다른 부분과는 독립적이거나 다른 부분에는 영향을 별로 미치지 않는 로직 분기점과 같은 곳이다.
오류를 전달하는 대신 기록만 하면 오류가 숨겨져 문제가 발생할 수 있다.

## 4. 오류를 숨기지 않음
앞서 살펴본 것처럼 전체 소프트웨어의 동작을 멈추지 않도록 하기 위해 코드의 독립적이거나 중요하지 않은 부분을 분리하면 견고한 시스템을 구축할 수 있다.
이것은 조심스럽게, 조금씩, 상당히 높은 계층의 코드에서 이루어져야 한다.
독립적이지 않거나, 중요하거나, 낮은 계층에서 오류가 발생함에도 불구하고 계속 진행하면 소프트웨어가 의도한 대로 작동하지 않는 경우가 많다.
오류가 적절히 기록되거나 보고되지 않으면 개발팀이 문제를 인식하지 못할 수 있다.

어떤 때는 실수를 숨기고 아무 일도 없었던 것처럼 동작하도록 코드를 작성하고 싶은 마음이 생길 수 있다.
이렇게 하면 코드가 훨씬 단순해지고 번거로운 오류 처리를 피할 수 있지만, 좋은 생각은 아니다.
오류를 숨기는 것은 복구할 수 있는 오류와 복구할 수 없는 오류 모두에 문제를 일으킨다.
- 호출하는 쪽에서 복구하고자 할 수도 있는 오류를 숨기면, 호출하는 쪽에서 오류로부터 복구할 수 있는 기회를 없애는 것이다.
  정확하고 의미 있는 오류 메시지를 표시하거나 다른 동작을 하는 대신, 잘못된 일이 일어날 수 있음을 전혀 알지 못하게 되고,
  이것은 곧 소프트웨어가 의도한 대로 작동하지 않을 가능성이 크다는 것을 의미한다.
- 복구할 수 없는 오류를 숨기면 프로그래밍 오류가 감춰진다.
  앞에서 신속하게 실패하는 것과 요란하게 실패하는 것에 대해 살펴봤듯이, 이러한 오류들은 개발팀이 알아야만 고칠 수 있다.
  그것들을 숨긴다는 것은 개발팀이 그 오류에 대해 전혀 알지 못할 수도 있다는 것을 의미하며, 버그는 꽤 오랫동안 알아차리지 못한 채 그대로 남아 있을 수 있다.
- 이 두 경우 모두 에러가 발생하면 일반적으로 호출하는 쪽에서 예측한 대로 코드가 실행되지 않는다는 것을 의미한다.
  오류를 감추면 호출하는 쪽에서는 모든 것이 잘 작동하고 있다고 가정하지만 실제로 코드는 제대로 동작을 못할 것이다.
  잘못된 정보를 출력하거나 일부 데이터를 손상시키거나 마침내 작동이 멈출 수 있다.

다음은 오류가 발생했다는 사실을 숨기 수 있는 몇 가지 방법을 다룬다.
이러한 기술 중 일부는 다른 상황에서 유용하지만 오류 처리에 있어서는 일반적으로 모두 바람직하지 않다.

### [기본값 반환]
오류가 발생하고 함수가 원하는 값을 반환할 수 없는 경우 기본값을 반환하는 것이 간단하고 쉬운 해결책처럼 보일 때가 있다.
이것과 비교해보면 적절한 에러 전달과 처리를 위해 코드를 추가하는 것은 많은 노력이 드는 것처럼 보일 수 있다.

기본값의 문제점은 오류가 발생했다는 사실을 숨긴다는 것인데, 이는 코드를 호출하는 쪽에서 모든 것이 정상인 것처럼 계속 진행한다는 것을 의미한다.

예제 4.3에는 고객 계좌의 잔액을 조회하는 코드가 포함되어 있다. 계정의 데이터 저장소에 액세스하는 동안 오류가 발생하면 함수는 기본값 0을 반환한다.
기본값 0을 반환하면 오류가 발생했다는 사실을 숨길 뿐만 아니라 고객의 잔액이 실제로 0인 경우와 구별할 수 없다.
호출하는 코드가 오류를 전달받고, 0을 보여주는 대신 '죄송합니다. 지금 이 정보에 액세스할 수 없습니다'라는 오류 메시지를 보여주면 더 나을 것이다.

#### [예제 4.3]
```java
class AccountManager {
  private final AccountStore accountStore;
  ...

  Double getAccountBalanceUsd(Int customerId) {
    AccountResult result = accountStore.lookup(customerId);
    if (!result.success()) {
      return 0.0;  // 오류가 발생하면 기본값 0이 반환된다.
    }
    return result.getAccount().getBalanceUsd();
  }
}
```
코드에 기본값을 두는 것이 유용한 경우가 있을 수 있지만, 오류를 처리할 때는 대부분의 경우 적합하지 않다.
잘못된 데이터로 시스템이 제대로 작동하지 못하게 만들고 오류가 나중에 이상한 방식으로 나타날 수 있기 때문에 신속한 실패와 요란한 실패의 원리를 위반하는 것이다.

### [널 객체 패턴]
널 객체는 개념적으로 기본값과 유사하지만 이것을 더 확장해서 더 복잡한 객체(클래스 등)를 다룬다.
널 객체는 실제 반환값처럼 보이지만 모든 멤버 함수는 아무것도 하지 않거나 의미 없는 기본값을 반환한다.

널 객체 패턴의 예는 빈 리스트의 반환과 같은 간단한 것부터 전체 클래스의 구현과 같은 복잡한 것까지 다양할 수 있다. 여기서는 빈 리스트의 예만 살펴보겠다.

예제 4.4 코드는 고객의 미지급 송장을 모두 조회하는 함수를 포함하고 있다. InvoiceStore에 대한 질의가 실패하면 함수는 빈 리스트를 반환한다. 이것은 버그로 이어지기 쉽다.
지불이 안된 송장으로 인해 이 고객은 수천 달러의 미결제액이 있음에도 불구하고 감사 실행 당일 InvoiceStore가 다운된다면, 함수를 호출하는 쪽에서 해당 고객은 미지불된 송장이 없다고 생각한다.

#### [예제 4.4] 빈 목록 반환
```java
class InvoiceManager {
  private final InvoiceStore invoiceStore;
  ...

  List<Invoice> getUnpaidInvoices(Int customerId) {
    InvoiceResult result = invoiceStore.query(customerId);
    if (!result.success()) {
      return [];  // 오류가 발생하면 빈 리스트를 반환한다.
    }
    return result
        .getInvoices()
        .filter(invoice -> !invoice.isPaid());
  }
}
```
널 객체 패턴은 디자인 패턴에 관한 것으로, 양날의 검이다.
널 객체 패턴을 사용하는 것이 꽤 유용한 경우가 있지만, 앞의 예에서 알 수 있듯이 오류 처리에 사용하는 것은 바람직하지 않다.

### [아무것도 하지 않음]
코드가 무언가를 반환하지 않고 단지 어떤 작업을 수행하는 경우, 문제가 발생할 때 가능한 한 가지 옵션은 오류가 발생했다는 신호를 보내지 않는 것이다.
호출하는 쪽에서는 코드에서 작업이 의도대로 완료되었다고 가정하기 때문에 일반적으로 이렇게 하는 것은 바람직하지 않다.
이것은 코드가 하는 일에 대해 개발자가 가지고 있는 정신 모델과 코드가 실제로 수행하는 것 사이의 불일치를 일으킬 가능성이 매우 높다.
이로 인해 소프트웨어에서 예상과 벗어나는 동작과 버그가 발생할 수 있다.

예제 4.5는 MutableInvoice에 항목을 추가하는 코드를 보여준다.
추가될 품목의 가격이 MutableInvoice에 들어 있는 항목의 통화와 다르면 오류이기 때문에 인보이스에 추가되지 않는다.
하지만 이 코드는 그 경우에 오류가 발생했고 항목이 추가되지 않았음을 알리지 않는다.
addItem() 함수를 호출하는 쪽에서는 해당 항목이 송장에 추가될 것이라고 예상하기 때문에 버그가 발생할 가능성이 매우 높다.

#### [예제 4.5] 오류 발생 시 아무것도 하지 않음
```java
class MutableInvoice {
  ...
  void addItem(InvoiceItem item) {
    if (item.getPrice().getCurrency() !=
        this.getCurrency()) {
      return;  // 통화가 일치하지 않으면 함수는 되돌아간다.
    }
    this.items.add(item);
  }
  ...
}
```
방금 살펴본 시나리오는 오류 신호를 보내지 않는 예다. 또 다른 시나리오는 다른 코드가 전달하는 오류를 적극적으로 억제하는 코드다. 예제 4.6은 이에 대한 코드다.
emailService.sendPlainText()를 호출해서 이메일을 전송할 때 오류가 발생하면 EmailException이 발생할 수 있다.
이 예외가 발생하면 코드는 이를 억제하고 호출하는 쪽에 실패에 대한 신호를 보내지 않는다.
이로 인해 소프트웨어에 버그가 일어날 가능성이 매우 높으며, 이 함수의 호출자는 이메일이 전송되지 않은 경우에도 전송된 것으로 가정할 것이다.

#### [예제 4.6] 예외 억제
```java
class InvoiceSender {
  private final EmailService emailService;
  ...

  void emailInvoice(String emailAddress, Invoice invoice) {
    try {
      emailService.sendPlainText(
        emailAddress,
        InvoiceFormat.plainText(invoice));
    } catch (EmailException e) { }  // EmailException이 발생하지만 무시된다.
  }
}
```
오류가 발생할 떄 이 오류를 기록하면 약간 개선된 것이긴 하지만 여전히 예제 4.6과 비슷하게 바람직하지 않은 코드다.
개발자가 로그를 확인하면 적어도 이러한 오류를 알아차리 수 있어서 이 코드는 약간 개선된 코드라고 할 수 있다.
그러나 여전히 호출하는 쪽에 오류를 숨기고 있어서 이메일이 실제로 발송되지 않는 경우에도 발송되었다고 가정할 수 있다.

#### [예제 4.7] 예외 탐지 및 오류 기록
```java
class InvoiceSender {
  private final EmailService emailService;
  ...

  void emailInvoice(String emailAddress, Invoice invoice) {
    try {
      emailService.sendPlainText(
        emailAddress,
        InvoiceFormat.plainText(invoice));
    } catch (EmailException e) {
      logger.logError(e);  // EmailException이 기록된다.
    }
  }
}
```
#### [기록되는 내용에 주의해야 한다]
예제 4.7에 있는 코드에서 또 하나의 불안한 점은 EmailException에 이메일 주소와 같은 사용자의 개인 정보가 포함될 가능성인데,
이 경우에는 특정 데이터 처리 정책의 적용을 받을 수 있다. 해당 이메일 주소를 오류 로그에 기록하면 해당 데이터 처리 정책에 위반될 수 있다.

예에서 알 수 있듯이 오류를 숨기는 것은 바람직하지 않다. 어떤 회사의 코드베이스에 앞의 예제와 같은 코드가 있다면,
그 회사는 수많은 미지급 송장과 재정적으로 불건전한 대차대조표를 갖게 될 것이다.
오류를 숨기면 실제적인(때로는 심각한) 결과가 발생할 수 있으며, 이를 알리는 것이 좋다.
