# 지나치게 일반적인 데이터 유형을 피하라
<br/>

정수, 문자열 및 리스트 같은 간단한 데이터 유형은 코드의 기본적인 구성 요소 중 하나다. 그것들은 믿을 수 없을 정도로 일반적이고, 다재다능하며, 다른 모든 것들을 대표할 수 있다.
일반적이고 다재다능하다는 것을 뒤집어 생각해보면 데이터 유형 자체만으로는 무언가를 설명할 수 없고, 가질 수 있는 값에 있어서도 꽤 관대하다는 것을 의미한다.

정수나 리스트와 같은 유형으로 표현이 '가능'하다고 해서 그것이 반드시 '좋은' 방법은 아니다. 설명이 부족하고 허용하는 범위가 넓을수록 코드 오용은 쉬워진다.
<br/>
<br/>
## 1. 지나치게 일반적인 유형은 오용될 수 있다
특정 정보를 완전히 표현하려면 종종 둘 이상의 값이 필요할 수 있다. 예를 들어 2D 지도의 위치는 위도와 경도에 대한 두 가지 값이 모두 필요하다.

지도에서 위치를 처리하는 코드를 작성할 경우 위치를 나타내는 자료구조가 필요할 수 있다. 자료구조에는 해당 위치의 위도와 경도에 대한 값이 모두 포함되어야 한다.
이를 위한 빠르고 간단한 방법은 리스트나 배열을 사용하는 것이다. 여기서 리스트의 첫 번째 값은 위도를 나타내고, 두 번째 값은 경도를 나타낸다.
즉, 하나의 위치는 List<Double>을 사용할 수 있고 여러 개의 위치는 List<List<Double>>을 사용할 수 있다. 다음 그림은 이것을 보여준다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/fa9a433d-6fc5-427c-ae42-f54d405df64e" width="500" height="250"/><br/>
- 리스트와 같은 매우 일반적인 데이터 유형을 사용하여 지도상의 위치를 위도와 경도 쌍으로 나타낼 수 있다. 하지만 가능하다고 해서 그것이 반드시 좋은 방법은 아니다.

하지만 리스트는 너무 일반적인 데이터 유형이다. 이런 식으로 리스트를 사용하면 코드를 오용하기 쉽다.
이 점을 설명하기 위해 예제 7.12 코드는 지도의 위치를 표시하는 클래스를 보여준다. markLocationOnMap() 함수는 위치 목록을 가져와서 하나의 위치를 지도에 표시한다.
다음 그림에서 보듯이 하나의 위치는 List<Double>로 표현하기 때문에 지도에 표시할 모든 위치는 List<List<Double>>로 나타낸다.
이렇게 하면 다소 복잡해지고, 입력 매개변수를 사용하는 방법을 설명하려면 문서가 필요하다.

#### [예제 7.12] 지나치게 일반적인 데이터 유형
```java
class LocationDisplay [
  private final DrowableMap map;
  ...

  /** ---> 입력 매개변수를 설명하기 위해 약간 복잡한 문서가 필요하다.
   * 지도 위에 제공된 모든 좌표의 위치를 표시한다.
   * 
   * 리스트의 리스트를 받아들이는데, 내부의 리스트는 정확히 두 개의 값을 가지고 있다.
   * 첫 번째 값은 위치의 위도이고 두 번째 값은 경도를 나타낸다 (둘 다 각도 값).
   */
  void markLocationOnMap(List<List<Double>> locations) {
    for (List<Double> location in locations) {
      map.markLocation(location[0], location[1]);  // 내부에 있는 각각의 리스트로부터 첫 번째와 두 번째 항목을 읽는다.
    }
  }
}
```
이것은 빠르고 쉬워 보이지만 다음 그림에서 볼 수 있듯이 코드를 오용하기 쉽게 만드는 단점이 있는데 다음과 같다.
- List<List\<Double\>> 유형 자체로는 아무것도 설명해주지 않는다.
  개발자가 markLocationsOnMap() 함수에 대한 주석문을 읽어보지 않는다면 이 리스트가 무엇인지, 어떻게 이해해야 하는지 알지 못할 것이다.
- 개발자는 리스트에서 어떤 항목이 위도와 경도인지 혼동하기 쉽다.
  만약 주석문을 완전히 읽지 않았거나 잘못 이해했다면, 위도와 경도의 순서를 뒤바꿀 수 있고, 이로 인해 버그가 발생할 것이다.
- 형식 안전성이 거의 없다. 컴파일러가 목록 내에 몇 개의 요소가 있는지 보장할 수 없다. 다음 그림에서 볼 수 있듯이 내부 리스트에 들어 있는 항목의 수가 잘못될 수 있다.
  이렇게 되면 코드가 정상적으로 컴파일되지만 런타임에 문제가 일어난다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/4609cbec-51c7-4e3b-bfe9-04dbd07ea892" width="500" height="280"/><br/>
- 이중 리스트를 사용하여 위도-경도 쌍과 같은 특정한 데이터를 표현하면 코드를 오용하기 쉬워진다.

요약하자면, 코드 계약의 세부 조항에 대한 자세한 지식(그리고 정확하게 따르는 것) 없이 markLocationsOnMap() 함수를 올바르게 호출하는 것은 거의 불가능하다.
다른 개발자가 어떤 작업을 수행하는 데 있어 세부 조항을 의지하는 것은 신뢰할 만한 방법이 아닌 경우가 많기 때문에
markLocationOnMap() 함수가 어느 시점에 잘못 사용될 수도 있고, 이로 인해 버그가 발생할 가능성이 크다.

### 패러다임은 퍼지기 쉽다
예를 들어 다른 개발자가 지도의 어떤 기능을 나타내는 클래스를 구현하고 있으며, 해당 클래스의 출력이 markLocationOnMap() 함수의 입력으로 사용된다고 가정해보자.
이 출력이 위치를 표현하기 위해 List<Double>을 사용하고 따라서 markLocationOnMap() 함수와 쉽게 상호작용할 수 있다.

예제 7.13은 이 클래스의 코드를 보여준다. getLocation() 함수는 위도와 경도를 포함하는 리스트를 반환한다.
함수의 반환 유형을 설명하기 위해 약간 복잡한 문서가 동일하게 필요한 점을 주목하기 바란다. 이것은 조금 우려되는 부분이다.
리스트에 위도와 경도를 저장하는 방법에 대한 지침이 두 개의 다른 위치, 즉 MapFeature 클래스와 LocationDisplay 클래스에 문서화된다.
이것은 진실의 원천이 하나가 아닌 둘이 되는 일례다. 이로 인해 버그가 발생할 수 있으며 이에 관해서는 7.6절에서 자세히 설명한다.

#### [예제 7.13] 같은 패러다임을 채택한 다른 코드
```java
class MapFeature {
  private final Double latitude;
  private final Double longitude;
  ...

  /* ---> 반환 유형을 설명하기 위해 약간 복잡한 문서화가 필요하다.
   * 2개의 요소를 갖는 리스트를 반환한다. 첫 번째 값은 위도를 나타내고 두 번째 값은 경도를 나타낸다(둘 다 각도 값).
   */
  List<Double> getLocation() {
    return [latitude, longitude];
  }
```
LocationDisplay.martLocationsOnMap() 함수의 작성자는 지도상의 위치를 나타내기 위해 List<Double>을 사용하는 것이 임시변통의 방법이라는 것을 알고 있을 것이다.
그러나 그것이 단지 하나의 함수에만 사용되기 때문에 코드베이스 전체에 해를 끼치지는 않을 것이라고 생각하고, 그런 임시변통을 사용한 것을 정당화할 수 있다.
문제는 이와 같은 임시변통으로 작성된 코드는 다른 코드 전반에 퍼지는 경향이 있다는 점이다.
다른 개발자들도 같은 방식으로 하지 않고는 이미 작성된 코드와 상호작용하기 어려워지기 때문이다. 이런 일은 상당히 빨리 그리고 광범위하게 확산될 수 있다.
또 다른 개발자가 MapFeature 클래스를 다른 용도로 사용해야 할 경우 어쩔 수 없이 List<Double>을 채택해야 한다.
어느새 우리도 모르는 사이에 리스트가 만연해 있기 때문에 이를 바로잡기가 매우 어려워진다.

## 2. 페어 유형은 오용하기 쉽다
많은 프로그래밍 언어에는 **페어**(pair) 데이터 유형이 있다.
이 데이터 유형은 표준 라이브러리의 일부일 때도 있고 그렇지 않은 경우 확장 라이브러리를 통해 제공되는 경우도 많다.

페어 데이터 유형의 요점은 동일하거나 다른 종류의 값을 두 개 저장한다는 것이다. 이 값을 각각 첫 번째, 두 번째라고 부른다.
페어 데이터 유형을 간단하게 구현하면 아래 예제 코드와 같다.

#### [예제 7.14] 페어 데이터 유형
```java
class Pair<A,B> {  // 제네릭(또는 템플릿)은 페어가 두 개의 값을 어떤 유형에 대해서라도 저장하도록 허용한다.
  private final A first;
  private final B second;

  Pair(A first, B second) {
    this.first = first;
    this.second = second;
  }

// 'first'와 'second'로 각각의 값을 참조한다.

  A getFirst() {
    return first;
  }

  B getSecond() {
    return second;
  }
}
```
List<Double>이 아니라 Pair<Double, Double>로 지도상의 위치를 나타내는 경우 markLocationsOnMap() 함수는 예제 7.15의 코드와 같다.
입력 매개변수를 설명하려면 여전히 상당히 복잡한 문서가 필요하며, 입력 매개변수 유형인 List<Pair<Double, Double>>은 무엇을 의미하는지 파악하기가 쉽지 않다는 점을
주의해서 봐야 한다.

#### [예제 7.15] 위치를 위해 페어 유형 사용
```java
class LocationDisplay {
  private final DrawableMap map;
  ...

  /** ---> 입력 매개변수를 설명하기 위해 어느 정도 복잡한 문서화가 필요하다.
   * 지도 위에 제공된 좌표의 모든 위치를 표시한다.
   * 
   * 페어의 리스트를 받아들이는데, 각 페어는 하나의 위치를 나타낸다.
   * 페어에서 첫 번째 값은 위도이고, 두 번째 값은 경도를 나타낸다.
   * (둘 다 각도 값)
   */
  void markLocationsOnMap(List<Pair<Double, Double>> locations) {
    for (Pair<Double, Double> location in locations) {
      map.markLocation(
          location.getFirst(),
          location.getSecond());
    }
  }
}
```
리스트 대신 Pair<Double>을 사용하면 이전 하위 절에서 언급한 일부 문제를 해결할 수 있다.
페어는 정확히 두 개의 값을 포함해야 하므로 호출하는 쪽에서 실수로 너무 적거나 많은 값을 제공하는 것을 방지한다. 그러나 다른 문제는 여전히 해결되지 않고 있다.
- List<Pair<Double, Double>>가 무슨 의미인지 여전히 이해하기 어렵다.
- 개발자는 여전히 위도와 경도의 순서에 대해 혼동하기 쉽다.

개발자는 markLocationOnMap() 함수를 올바르게 호출하려면 여전히 코드 계약의 세부 조항에 나와 있는 자세한 내용을 확인해야 하고,
따라서 Pair<Double, Double>을 사용하는 것은 훌륭한 해결책이라고 볼 수 없다.

## 3. 해결책: 전용 유형 사용
1장에서 지름길을 택하는 것이 중장기적으로는 어떻게 더 느려지는지 설명했다.
아주 구체적인 것에 대해 지나치게 일반적인 데이터 유형(예: 리스트나 페어)을 사용하는 것이 이러한 지름길의 예가 될 수 있다.
무언가를 나타내기 위해 새로운 클래스(또는 구조체)를 정의하는 것은 많은 노력이 들거나 불필요한 것처럼 보일 수 있지만,
대부분 보기보다 노력이 덜 들어가고 다른 개발자가 코드를 읽을 때 이해하기 쉽고 버그의 가능성도 줄여준다.

지도의 2D 위치를 나타내는 경우 코드의 오용 혹은 오해의 소지를 줄이는 간단한 방법은 위도와 경도를 나타내는 전용 클래스를 정의하는 것이다.
예제 7.16의 코드는 이렇게 위도와 경도를 위한 새로운 클래스를 보여준다. 이 클래스는 매우 간단하고, 코드를 작성하고 테스트하는 데 몇 분 이상은 걸리지 않을 것이다.

#### [예제 7.16] LatLong 클래스
```java
/**
 * 위도와 경도를 각도로 나타낸다.
*/
class LatLong {
  private final Double latitude;
  private final Double longitude;

  LatLong(Double latitude, Double longitude) {
    this.latitude = latitude;
    this.longitude = longitude;
  }

  Double getLatitude() {
    return latitude;
  }

  Double getLongitude() {
    return longitude;
  }
}
```
이 새로운 LatLong 클래스를 사용하는 markLocationOnMap() 함수는 예제 7.17 코드와 같다.
이제 의미가 자명하기 때문에 복잡한 입력 매개변수를 사용하기 위한 문서가 필요하지 않다. 또한 유형 안전성이 높아졌고 위도와 경도를 혼동할 일이 없다.

#### [예제 7.17] LatLong 사용
```java
class LocationDisplay {
  private final DrawableMap map;
  ...

  /**
   * 지도 위에 제공된 모든 좌표의 위치를 표시한다.
   */
  void markLocationsOnMap(List<LatLong> locations) {
    for (LatLong location in locations) {
      map.markLocation(
          location.getLatitude(),
          location.getLongitude());
    }
  }
}
```
일반적이고 바로 가져다 쓸 수 있는 데이터 유형을 사용하는 것이 때로는 빠르고 쉬운 방법처럼 보일 수 있다.
하지만 무언가 구체적인 것을 나타낼 필요가 있을 때, 적은 노력을 추가로 들여서 전용 유형을 정의하는 것이 더 나을 때가 많다.
코드가 훨씬 더 명확해지고 오용하기 어렵기 떄문에 중장기적으로 보자면 시간이 절약된다.

#### [데이터 객체]
데이터를 그룹으로 묶기만 하는 간단한 객체를 정의하는 것은 상당히 일반적인 작업이며 많은 언어에서 이것을 쉽게 해주는 기능(또는 확장 유틸리티)이 있다.
- 코틀린(Kotlin)에는 데이터 클래스라는 개념이 있는데, 한 줄짜리 코드를 사용하여 데이터를 포함하는 클래스를 정의할 수 있다(http://mng.bz/O15j).
- 자바 최신 버전에서는 레코드를 사용할 수 있다(https://openjdk.java.net/jeps/395). 이전 버전의 자바에서는 오토밸류(AutoValue)를 대안으로 사용할 수 있다(https://mng.bz/YAaj).
  - 자바 레코드는 자바 14부터 지원된다. (https://docs.oracle.com/en/java/javac/14/language/records.html)
- 다양한 언어(ex: C++, C#, Swift, Rust)에서 구조체(struct)를 정의할 수 있으며, 클래스 정의보다 간단하다.
- 타입스크립트(TypeScript)에서는 인터페이스를 정의한 다음 이를 사용하여 객체가 반드시 포함해야 하는 속성에 대해 컴파일 타임 안전성을 제공할 수 있다(https://mng.bz/G6PA).

객체 지향 프로그래밍에 대한 전통적인 관점을 지지하는 사람들은 때때로 데이터 전용 객체를 정의하는 것을 잘못된 관행으로 간주한다.
이들은 데이터와 데이터에 대한 기능이 모두 동일한 클래스에 캡슐화되어야 한다고 주장한다.

데이터가 어떤 기능과 밀접하게 결합되어 있는 경우 이 주장은 상당히 타당하다. 그러나 특정 기능에 데이터를 연결하지 않고도 데이터를 그룹화하는 것이 유용한 상황이 있다.
이 경우에는 데이터 전용 객체가 매우 유용할 수 있다.
