# 제네릭의 사용을 고려하라
<br/>

클래스는 종종 다른 유형 혹은 클래스의 인스턴스나 참조를 갖는다. 이것의 대표적인 예는 리스트 클래스다.
문자열 리스트가 있으면 리스트 클래스는 문자열 클래스의 인스턴스를 갖는다. 리스트에 항목을 저장하는 것은 매우 일반적인 하위 문제다.
어떤 경우에는 문자열 리스트가 필요하지만 다른 경우에는 정수 리스트가 필요할 수 있다.
문자열과 정수를 저장하기 위해 완전히 다른 별개의 리스트 클래스가 필요하다면 상당히 번거로울 것이다.

다행히도 많은 언어가 **제네릭**(generic) 혹은 **템플릿**(template)을 지원한다. 제네릭을 통해 참조하는 모든 유형을 구체적으로 명시할 필요 없이 클래스를 작성할 수 있다.
리스트의 경우 동일한 클래스를 사용하여 원하는 유형을 쉽게 저장할 수 있는데 여러 가지 유형을 저장하는 예는 다음과 같다.
```java
List<String> stringList = ["hello", "world"];

List<Int> intList = [1, 2, 3];
```
다른 클래스를 참조하는 코드를 작성하지만 그 클래스가 어떤 클래스인지 신경 쓰지 않는다면 제네릭의 사용을 고려해야 한다.
제네릭을 사용하면 아주 적은 양의 추가 작업이 있긴 하지만 코드의 일반화가 크게 향상된다. 다음 하위 절에서 이에 대한 예가 나온다.
<br/>
<br/>
## 1. 특정 유형에 의존하면 일반화를 제한한다
단어 맞히기 게임을 개발한다고 가정해보자. 게임 참여자들이 각각 단어를 제출한 다음 돌아가면서 한 단어씩 동작으로 설명하면 다른 선수들이 어떤 단어인지 맞혀야 한다.
해결해야 할 하위 문제 중 하나는 단어 모음을 저장하는 것이다. 또한 한 단어씩 무작위로 선택할 수 있어야 하고, 제한 시간 내에 맞히지 못한다면 그 단어는 다시 단어 모음에 들어가야 한다.

무작위 큐를 구현함으로써 이 하위 문제를 해결하기로 결정한다면 예제 코드 9.20은 이것을 구현하는 RandomizedQueue 클래스를 보여준다.
이 클래스는 문자열의 모음(collection)을 저장한다. add()는 새 문자열을 추가하고 getNext()는 모음에서 임의의 문자열을 삭제하고 그 문자열을 반환한다.
RandomizedQueue 클래스는 String에 대한 의존도가 높기 때문에 다른 유형을 저장하는 데는 사용할 수 없다.

#### [예제 9.20] 문자열 유형을 하드 코딩해서 사용
```java
class RandomizedQueue {
  private final List<String> values = [];  // 하드 코드로 String을 사용

  void add(String value) {
    values.add(value);
  }

  /**
   * 큐로부터 무작위로 한 항목을 삭제하고 그 항목을 반환한다.
   */
  String? getNext() {
    if (values.isEmpty()) {
      return null;
    }
    Int randomIndex = Math.random(0, values.size());
    values.swap(randomIndex, values.size() - 1);
    return values.removeLast();
  }
}
```
이 코드에서와 같이 RandomizedQueue를 구현하면 문자열로 표현될 수 있는 단어를 저장하는 특정한 유형의 문제는 해결하지만 다른 유형의 동일한 하위 문제를 해결할 수 있을 만큼
일반화되어 있지는 않다. 게임 참여자가 단어 대신 사진을 보고 설명하고 그 외 나머지는 다 동일한 게임을 다른 팀에서 개발한다고 가정해보자.
두 게임 사이의 많은 하위 문제들은 거의 동일하지만 문자열을 사용하도록 하드 코딩되어 있기 때문에 이 코드는 다른 팀이 풀어야 할 하위 문제를 해결해 줄 만큼 일반화되지 않은 상태다.
코드가 일반화되어 거의 동일한 하위 문제를 해결할 수 있다면 훨씬 더 바람직할 것이다.

## 2. 해결책: 제네릭을 사용하라
RandomizedQueue 클래스의 경우 제네릭을 사용하면 코드를 일반화하는 것이 아주 쉽다.
하드 코딩으로 String에 대한 의존성을 갖는 대신, 이 클래스를 나중에 사용할 때 어떤 유형을 사용할지 지시할 수 있는 자리 표시자(또는 템플릿)를 지정할 수 있다.
예제 9.21은 RandomizedQueue 클래스가 제네릭을 사용하는 경우를 보여준다. 클래스 정의는 class RandomizedQueue<T>로 시작한다.
<T>는 컴파일러에게 T가 타입의 자리 표시자로 사용할 것이라고 알려준다. 이렇게 하면 클래스 정의에서 T를 실제 유형인 것처럼 사용할 수 있다.

#### [예제 9.21] 제네릭 사용
```
class RandomizedQueue<T> {  // T는 제네릭의 유형에 대한 자리 표시자다.
  private final List<T> values = [];  // 유형 자리 표시자는 클래스 내에서 사용할 수 있다.

  void add(T value) {
    values.add(value);
  }

  /**
   * 큐에서 무작위로 한 항목을 삭제한 후에 그 항목을 반환한다.
   */
  T? getNext() {
    if (values.isEmpty()) {
      return null;
    }
    Int randomIndex = Math.random(0, values.size());
    values.swap(randomIndex, values.size() - 1);
    return values.removeLast();
  }
}
```
RandomizedQueue 클래스는 이제 원하는 어떤 것이라도 저장할 수 있으므로 단어를 사용하는 게임 버전에서는 다음과 같이 문자열을 저장하는 클래스로 정의할 수 있다.
```java
RandomizedQueue<String> words = new RandomizedQueue<String>();
```
사진을 저장하고자 하면 다음과 같이 사진을 저장하는 클래스로 쉽게 정의할 수 있다.
```java
RandomizedQueue<Picture> pictures =
    new RandomizedQueue<Picture>();
```

#### [제네릭 및 널 형식]
예제 9.21 코드에서 getNext() 함수는 큐가 비어 있으면 널을 반환한다. 널값을 큐에 저장하지 않는 한 이 방법은 문제가 없고 이렇게 가정하는 것은 합리적이다
(3장에서 논의한 것처럼 확인(check)이나 어서션(assertion)을 사용해 이 가정을 강제로 적용하는 것을 고려할 수 있다).<br/>
RandomizedQueue<String?>과 같이 정의하고 널값을 대기열에 저장하려 한다면 문제가 될 수 있다
getNext()가 널값을 반환할 때 이것이 큐 내에 존재하는 널값인지 아니면 큐가 비어 있다는 것인지 구별할 수 없기 때문이다.
이런 경우를 지원하고자 한다면 getNext()를 호출하기 전에 큐가 비어 있지 않은지 확인할 수 있는 hasNext() 함수를 제공할 수 있다.
<br/>
<br/>
높은 수준의 문제를 하위 문제로 세분화하다 보면 다양한 사례에 적용할 수 있는 매우 근본적인 문제를 접한다.
하위 문제에 대한 해결책이 모든 데이터 유형에 쉽게 적용될 수 있을 때 특정 유형에 의존하는 대신 제네릭을 사용하더라도 추가적인 노력이 거의 들어가지 않는다.
이렇게 하면 코드는 보다 더 일반화되고 재사용이 가능하다는 측면에서 쉽게 효과를 볼 수 있다.
