# 시간 처리
<br/>

앞 절에서는 지나치게 일반적인 데이터 유형을 사용하여 특정 항목을 나타내는 경우 코드가 오용되기 쉬워지는 것에 관해 살펴봤다.
이에 관한 한 가지 구체적인 예가 시간과 관련한 개념을 나타내는 것인데 생각지도 못한 상황에서 튀어나온다.

시간은 단순한 것처럼 보일지 모르지만, 실제로 시간을 나타내는 것은 다음과 같은 점에서 상당히 까다롭다.
- 어떤 때는 '1969년 7월 21일 02:56 UTC'와 같이 절대적인 시간을 지칭하지만 또 다른 때는 '5분 내'와 같은 상대적인 시간으로 표현한다.
- '오븐에서 30분 굽기'와 같은 시간의 양을 언급하는 경우도 있다. 시간은 분, 초, 밀리초 등 다양한 단위 중 하나로 표시할 수 있다.
- 표준 시간대, 일광 절약 시간, 윤년(leap year), 심지어 윤초(leap second)와 같은 개념도 있어서 상황이 훨씬 더 복잡하다.

시간을 다룰 때 코드를 잘못 사용하고 혼동을 일으킬 여지가 굉장히 많다.
이번 절에서는 시간에 기초한 개념을 다룰 때 적절한 데이터 유형과 언어 구성 요소를 사용하여 혼동과 오남용을 방지할 수 있는 방법을 논의한다.
<br/>
<br/>
## 1. 정수로 시간을 나타내는 것은 문제가 될 수 있다
시간을 나타낼 때 일반적으로 정수나 큰 정수(long integer)를 사용한다. 이것으로 어느 한순간을 의미하는 시각과 시간의 양, 두 가지를 모두 나타낸다.
- 순간으로서의 시간은 유닉스 시간(unix epoch)인 1970년 1월 1일 00:00:00 UTC 이후 몇 초(윤초는 무시)로 표현하는 경우가 많다.
- 양으로서의 시간은 초 혹은 밀리초 단위로 표시할 때가 많다.

정수는 매우 일반적인 유형이기 때문에 시간을 나타내는 데 사용하는 경우 코드가 오용되기 쉽다. 이러한 일이 발생할 수 있는 세 가지 일반적인 경우에 대해 살펴보자.

### 한순간의 시간인가, 아니면 시간의 양인가?
예제 7.18 코드를 고려해보자. sendMessage() 함수는 deadline이라는 정수 매개변수가 있다.
함수의 주석문에는 deadline 매개변수가 하는 일과 단위가 초라는 것이 나와있지만, 이 값이 실제로 무엇을 나타내는지에 대한 설명은 없다.
따라서 함수를 호출할 때 deadline 매개변수에 대한 인수로 무엇을 제공해야 하는지 명확하지 않다. 다음과 같은 몇 가지 경우가 가능하다.
- 매개변수는 시간의 절대 순간을 나타내며, 유닉스 시간 이후 경과된 초를 제공해야 한다.
- 매개변수는 시간의 양을 나타낸다. 이 함수가 호출되면 타이머가 시작되고 타이머가 지정된 시간(초)에 도달하면 시한이 지난다.

#### [예제 7.18] 순간으로서의 시간 혹은 양으로서의 시간?
```java
/**
 * @param message 보낼 메시지
 * @param deadline 데드라인은 초 단위다.
 *     데드라인이 경과하기까지 메시지가 전송되지 않으면 전송은 취소된다.
 * ---> 매개변수가 하는 일과 단위를 설명하지만 값의 의미는 설명하지 않는다.
 * @return 메시지가 전송되면 참을 그렇지 않으면 거짓
 */
Boolean sendMessage(String message, Int64 deadline) {
  ...
}
```
이 정도의 모호함이 있다면 문서화가 훌륭하지 않다는 점이 분명하다.
주석문을 개선하면 모호함이 줄어들고 좀 더 명확해지겠지만, 코드 계약의 세부 조항에 더 많은 내용이 추가될 것이다.
세부 조항은 코드의 오용을 방지하기 위한 방법으로서 신뢰하기는 어렵다.
그리고 이 매개변수에 대해 이미 세줄에 걸쳐 설명되어 있는 점을 고려하면, 값이 나타내는 바를 설명하기 위해 더 많은 내용을 추가하는 것이 최상의 방법은 아니다.

### 일치하지 않는 단위
이번 절의 시작 부분에서 언급한 바와 같이 시간을 측정하는 데 사용하는 단위가 다르다.
코드에서 사용하는 가장 일반적인 단위는 대개 밀리초(millisecond) 혹은 초(second)지만 경우에 따라 마이크로초(microsecond)와 같은 단위도 사용한다.

정수 유형은 값이 어떤 단위에 있는지 나타내는 데 전혀 도움이 되지 않는다.
함수 이름, 매개변수 이름, 주석문을 사용하여 단위를 나타낼 수 있지만, 여전히 코드를 오용하기가 상대적으로 쉽다.

예제 7.19는 한 코드베이스 내에서 두 가지 다른 코드를 보여준다. UiSettings.getMessageTimeout() 함수는 초를 나타내는 정수를 반환한다.
showMessage() 함수는 밀리초를 나타내는 timeoutMs라는 매개변수가 있다.

#### [예제 7.19] 시간 단위의 불일치
```java
class UiSetting {
  ...

  /**
   * @return UI 메시지를 보여주는 초 단위 기간 ---> 이 부분은 초를 사용한다.
   */
  Int64 getMessageTimeout() {
    return 5;
  }
}

...

/**
 * @param message 보여줄 메시지
 * @param timeoutMs 메시지를 보여주는 밀리초 단위의 기간 ---> 이 부분은 밀리초를 사용한다.
 */
void showMessage(String message, Int64 timeoutMs) {
  ...
}
```
주석문과 timeMs 매개변수 이름 뒤에 붙은 'Ms'라는 접미사에도 불구하고, 개발자는 이 두 부분의 코드를 함께 연결해서 사용할 떄 실수하기 쉽다.
아래의 함수 호출 코드는 무엇이 잘못됐는지 명백하지 않지만, '경고'라는 메시지가 5초가 아닌 5밀리초 동안 표시된다. 사용자가 미처 알아차리기도 전에 메시지가 사라질 것이다.
```java
showMessage("Warning", uiSettings.getMessageTimeout());
```

### 시간대 처리 오류
순간으로서의 시간은 일반적으로 유닉스 시간 이후 지나간 초(윤초는 무시)로 나타낸다.
이것을 보통 타임스탬프(timestamp)라고 부르는데, 이벤트가 발생했거나 발생할 시간을 정확하게 식별하기 위한 방법이다.
하지만 사람인 우리는 종종 시간에 관해 말할 때 그렇게 정확하게 표현하지 않는다.

예를 들어 생일에 대해 말할 때 누군가 1990년 12월 2일에 태어났다면, 그가 태어난 정확한 순간에 대해 특별히 신경 쓰지 않는다.
대신 매년 날짜가 12월 2일이 되면 생일을 축하하고 케이크를 먹는다는 것에 신경을 쓴다.

날짜와 순간의 차이는 미묘한 것일 수 있지만, 이 두 가지를 다른 방식으로 다루지 않는다면 문제가 될 수 있다. 다음 그림은 이 상황이 어떻게 잘못될 수 있는지를 보여준다.
사용자가 날짜(생일 등)를 입력하고 이를 로컬 표준시 내의 날짜 및 시간으로 해석하면 다른 표준시 사용자가 정보에 액세스할 때 다른 날짜가 표시될 수 있다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/95eadb2f-23d5-4687-a80d-37028f22c4b8" width="500" height="400"/><br/>
- 시간대를 적절하게 처리하지 않으면 버그가 발생할 수 있다

서버가 서로 다른 위치에서 실행되고 시스템을 다른 표준 시간대로 설정한 경우 위 그림에서 설명한 것과 유사한 문제가 서버단의 논리만으로도 발생할 수 있다.
예를 들어 유럽에 있는 서버가 처리한 날짜 값이 캘리포니아에 있는 서버에 의해 저장될 수 있다.

순간으로서의 시간, 양으로서의 시간, 날짜와 같은 시간에 기초한 개념은 최상의 경우라 할지라도 사용하기에 까다롭다.
하물며 정수와 같은 매우 일반적인 유형을 사용해 그러한 것들을 표현하려고 한다면 자신뿐만 아니라 다른 개발자까지도 어렵게 만드는 것이다.
정수는 값이 의미하는 바나 나타내고자 하는 정보를 거의 전달하지 못하기 때문에 값을 오용하기 쉽게 만들 수 있다.
다음 하위 절에서는 보다 적절한 유형을 사용해서 어떻게 시간을 처리하는 코드를 개선할 수 있을지 설명한다.

## 2. 해결책: 적절한 자료구조를 사용하라
우리가 알 수 있듯이 시간을 다루는 것은 복잡하고 까다로운 일이며 혼란의 여지가 많다. 
대부분의 프로그래밍 언어에는 시간을 처리하기 위한 내장 라이브러리가 있지만, 불행히도 이들 중 일부는 오류를 일으키기 쉬운 단점이나 설계 문제를 가지고 있다.
그나마 다행인 점은 시간과 관련한 개념에 대해 자체 지원이 부족한 프로그래밍 언어의 경우, 대부분은 타사 혹은 제3자 오픈소스 라이브러리(open source library)를 통해
보다 강력한 유틸리티로 제공된다는 점이다.
따라서 시간에 기초한 개념을 견고하게 처리하는 방법이 있지만, 사용하는 언어에 가장 적합한 라이브러리를 찾기 위해 노력을 기울여야 한다. 사용 가능한 예는 다음과 같다.
- 자바에서는 java.time 패키지의 클래스를 사용할 수 있다(https://mng.bz/0rPE).
  - 자바의 경우 java.util 패키지 내에도 시간 관련 클래스가 있지만 앞서 살펴본 불변성과 관련해서 이 클래스들은 가변적이기 때문에
    java.util 내의 시간 관련 클래스는 더 이상 사용하지 않도록 권고하고 있다.
- C#에서 노다(Noda) 시간 라이브러리는 견고하게 시간을 처리하기 위한 여러 유틸리티를 제공한다(https://nodatime.org).
- C++에서 크로노(chrono) 라이브러리를 사용할 수 있다(https://en.cppreference.com/w/cpp/chrono).
- 자바스크립트에는 선택할 수 있는 많은 서드 파티 라이브러리가 있다. 일례로 js-joda 라이브러리(https://js-joda.github.io/js-joda/)가 있다.

이러한 라이브러리를 사용하면 이전 하위 절에서 논의한 문제를 훨씬 쉽게 처리할 수 있다. 다음 하위 절에서는 이러한 라이브러리를 사용해 코드를 개선할 수 있는 방법을 설명한다.

### 양으로서의 시간과 순간으로서의 시간의 구분
Java.time 패키지나, 노다 타임(Noda Time) 및 js-joda 라이브러리는 모두 Instant라는 클래스와 Duration이라는 클래스를 제공한다.
마찬가지로, C++ 크로노 라이브러리도 time_point라는 클래스와 duration이라는 클래스를 제공한다.

이 중 하나를 사용하면 함수 매개변수의 유형이 나타내는 것이 순간인지 아니면 시간의 양인지 알 수 있다.
예를 들어 앞에서 본 sendMessage() 함수는 Duration 유형을 사용하는 경우 예제 7.20의 코드와 같을 것이다.
이 코드에서 값은 한순간의 시간이 아니라 시간의 양을 나타낸다는 점은 너무나 명백하다.

#### [예제 7.20] Duration 유형 사용
```java
/**
 * @param message 보낼 메시지
 * @param deadline 데드라인이 경과하기까지 메시지가 전송되지 않으면 전송은 취소된다.
 * @return 메시지가 전송되면 참을, 그렇지 않으면 거짓을 반환한다.
 */
Boolean sendMessage(String message, Duration deadline) {  /** Duration 유형으로 인해
  ...                                                      * deadline이 나타내고자 하는 바가 명백하다.
}                                                          */
```

### 더 이상 단위에 대한 혼동이 없다
Instant 및 Duration과 같은 유형이 제공하는 또 다른 이점은 단위가 유형 내에 캡슐화되어 있다는 점이다.
따라서 어떤 단위가 사용되어야 하는지 설명하기 위한 계약의 세부 조항이 필요하지 않으며, 실수로 잘못된 단위를 제공하는 것이 불가능하다.
다음 코드는 서로 다른 팩토리 함수를 사용해서 서로 다른 단위에 대한 Duration 객체를 생성하는 것을 보여준다.
Duration 객체를 만드는 데 사용하는 단위에 관계없이 나중에 밀리초 단위로도 다시 읽을 수 있다.
이를 통해 코드의 서로 다른 부분이 상호작용할 때 원하는 어떤 단위라도 불일치의 위험 없이 사용할 수 있다.
```java
Duration duration1 = Duration.ofSeconds(5);
print(duration1.toMills());  // 출력: 5000

Duration duration2 = Duration.ofMinutes(2);
print(duration2.toMillis());  // 출력: 120000
```

다음 예제 코드는 메시지가 타임아웃될 시간의 양을 처리하기 위해 정수 대신 Duration 유형을 사용하는 경우, 어떻게 showMessage() 함수의 문제가 해결되는지를 보여준다.

#### [예제 7.21] Duration 유형에 캡슐화된 단위
```java
class UiSettings {
  ...

  /**
   * @return UI 메시지를 보여주는 기간
   */
  Duration getMessageTimeout() {  // Duration 유형은 단위를 캡슐화한다.
    return Duration.ofSeconds(5);
  }
}

...

/**
 * @param message 보여줄 메시지
 * @param timeout 메시지를 보여주는 시간의 양
 */
void showMessage(String messge, Duraion timeout) {
  ...
}
```

### 시간대 처리 개선
생일을 나타내는 예에서 생일이 실제로 어느 시간대인지는 신경 쓰지 않는다.
하지만 생일을 타임스탬프를 사용해서 정확한 순간과 연결해서 표현하고 싶다면, 시간대에 대해 신중하게 생각할 수밖에 없다.
다행히도 시간을 다루는 라이브러리는 종종 이렇게 정확한 순간과 연결하지 않고도 날짜(및 시간)를 나타낼 수 있는 방법을 제공한다.
Java.time 패키지, 노다 타임 및 js-joda 라이브러리는 모두 `LocalDateTime`이라는 클래스를 제공하는데 이 클래스를 통해 이런 작업을 정확하게 수행할 수 있다.

이번 절에서 알 수 있듯이 시간을 다루는 것은 까다로운 일이고, 부주의하게 작성하면 오용하기 쉽고, 버그를 유발하는 코드가 될 수 있다.
다행히도 이러한 문제를 이미 직면한 개발자들이 시간을 훨씬 더 견고하게 다루기 위한 라이브러리들을 많이 구축해놨다. 우리는 그것들을 사용함으로써 코드를 개선할 수 있다.
