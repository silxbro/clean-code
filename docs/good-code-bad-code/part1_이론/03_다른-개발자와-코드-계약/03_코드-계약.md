# 코드 계약
<br/>

**계약에 의한 프로그래밍**(programming by contract) 또는 **계약에 의한 디자인**(design by contract)이라는 용어를 접해 본 적이 있을 것이다.
이 원칙은 이전 절에서 논의한 개념들 중 일부를 공식화하는 원칙으로 다른 사람들이 어떻게 코드를 사용할지, 그리고 코드가 무엇을 할 것으로 기대할 수 있는지에 대한 것이다.
이 철학에서는 서로 다른 코드 간의 상호작용을 마치 계약처럼 생각한다.
어떤 코드를 호출하는 코드는 특정 요건을 충족해야 하며 호출되는 코드는 원하는 값을 반환하거나 일부 상태를 수정한다.
모든 것이 이 계약에서 정의되기 때문에 분명하지 않은 것이 없고 예상과 다르게 실행되는 것도 없다.

코드의 계약에 대한 용어를 다음과 같은 세 가지 범주로 나누면 유용하다.
- **선결 조건**(precondition)
  - 코드를 호출하기 전에 사실이어야 하는 것. 예를 들어 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지와 같은 사항
- **사후 조건**(postcondition)
  - 코드가 호출된 후에 사실이어야 하는 것. 예를 들어 시스템이 새로운 상태에 놓인다든지 반환되는 값과 같은 사항
- **불변 사항**(invariant)
  - 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항
 
의도적으로 계약에 의한 프로그래밍을 하지 않고 이 용어에 대해 한 번도 들어본 적이 없다 해도, 여러분이 작성하는 코드는 어떤 종류의 계약을 맺는 것이라고 봐도 무방하다.
입력 매개변수가 있는 함수를 작성하거나, 값을 반환하거나, 어떤 상태를 수정하면 이것은 계약을 생성한 것이 되는데,
그 이유는 코드를 호출하는 사람에게 무언가를 설정하거나 입력(선결 조건)을 제공해야 할 요건을 부여하고,
호출 결과 일어날 일 혹은 반환될 값(사후 조건)에 대한 기대를 갖게 하기 때문이다.

개발자가 계약의 일부 혹은 모든 조건을 알지 못하면 코드 계약에 문제가 발생한다.
코드를 작성할 때, 만들어지는 계약의 내용이 무엇일지 그리고 어떻게 하면 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지에 대해 생각하는 것이 중요하다.
<br/>

## 1. 계약의 세부 조항
계약서에는 일반적으로 약관의 조건 사항과 같은 세부 항목이 포함되어 있다. 이와 비슷하게 코드에서 계약을 정의할 때도 명확한 부분과 세부 조항이 있다.

- 계약의 명확한 부분
  - **함수와 클래스 이름**
    - 호출하는 쪽에서 이것을 모르면 코드를 사용할 수 없다.
  - **인자 유형**
    - 호출하는 쪽에서 인자의 유형을 잘못 사용하면 코드는 컴파일조차 되지 않는다.
  - **반환 유형**
    - 호출하는 쪽에서 함수의 반환 유형을 알아야 한다. 이 유형과 일치하지 않는 유형을 사용하면 코드는 컴파일되지 않는다.
  - **검사 예외**(checked exception)
    - (언어에서 지원하는 경우에 한해) 호출하는 코드가 이것을 처리하지 않으면 코드는 컴파일되지 않는다.
- 세부 조항
  - **주석문과 문서**
    - 실제 계약의 세부 조항에 대해 그렇듯이 꼼꼼하게 모두 다 읽어봐야 하는 것임에도 실제로는 잘 읽지 않는다. 개발자는 이 사실을 실용적인 관점에서 봐야 한다.
  - **비검사 예외**(unchecked exception)
    - 주석문에 이 예외가 나열되어 있다면 이것은 세부 조항이다. 어떤 때는 심지어 세부 조항에도 나와 있지 않을 수도 있다.
      예를 들어 몇 계층 아래에서 함수가 비검사 예외를 생성하지만 이 함수의 작성자가 문서에서 그것을 언급하는 것을 잊어버리는 경우다.

코드 계약에서 조건을 명백하게 하는 것이 세부 조항을 사용하는 것보다 훨씬 낫다.
사람들은 세부 조항을 읽지 않는 경우가 매우 많으며,심지어 읽더라도 그것을 대충 훑어보기 때문에 잘못 이해할 수 있다.
그리고 앞부분에서 논의한 바와 같이 문서화는 업데이트가 제때 되지 않기 때문에 세부 조항이 항상 정확한 것도 아니다.

## 2. 세부 조항에 너무 의존하지 말라
주석문과 문서의 형태로 된 세부 조항은 간과하고 넘어갈 때가 많기 때문에 다른 개발자들이 해당 코드를 사용할 때 모든 세부 조항을 다 알지 못할 가능성이 크다.
따라서 코드 계약을 전달할 때 세부 조항을 사용하는 것은 신뢰할 만한 방법이 아니다.
세부 조항에 너무 많이 의존하면 오용하기 쉬운 취약한 코드가 될 가능성이 크고, 예상과 다르게 동작하기 쉽다. 이 두 가지는 모두 고품질 코드의 적이다.

세부 조항에 의존하는 것을 피할 수 없는 경우도 있다. 어떤 문제들은 항상 주의 사항이 있고 이것을 설명해야 한다.
또는 어쩔 수 없이 다른 사람이 작성한 저품질의 코드에 의존해야 할 때도 있는데, 이 경우 자신의 코드는 약간 이상하게 동작할 수밖에 없다.
이 때는 이런 상황을 설명하는 문서화된 세부 조항이 필요하고, 다른 개발자들이 이 문서를 읽도록 해야 한다.
하지만 문서화의 중요성에도 불구하고 다른 개발자들이 그것을 읽지 않을 가능성이 크거나, 시간이 흐르면서 업데이트가 안 될 가능성이 크기 때문에 문서화는 아주 이상적인 방법은 아니다.
명확하지 않을 수도 있는 사항들을 문서화하는 것은 일반적으로 좋은 생각이지만, 너무 많이 의존하지 않는 것이 최선의 방법이다.
코드 계약의 분명한 항목을 통해 코드에 관해 명확하게 설명하는 것이 가능하다면 그렇게 하는 것이 더 바람직할 때가 많다.

이를 설명하고자 다음 예제 코드(예제 3.1)는 클래스가 일부 사용자 설정을 로드하고 액세스할 수 있는 코드를 보여준다.
이 코드는 클래스를 어떻게 사용해야 하는지에 대한 계약을 정의하지만 이 클래스를 사용하려면 모든 세부 조항을 알아야 한다.
클래스를 생성한 후, 일부 설정을 로드하는 함수를 호출하고, 그다음 초기화 함수를 호출해야 한다. 이 모든 일이 올바른 순서로 이루어지지 않는다면 이 클래스는 잘못된 상태에 놓이게 된다.

#### [예제 3.1] 세부 조항이 많은 코드
```java
class UserSettings {

  UserSettings() { ... }


/***** 이와 같은 문서는 코드 계약의 세부 조항에 해당한다. *****/

  // 이 함수를 사용해 설정이 올바르게 로드되기 전까지는 다른 어떤 함수도    
  // 호출해서는 안 된다.
  // 설정이 성공적으로 로드되면 참을 반환한다.
  Boolean loadSettings(File location) { ... }

  // init()은 다른 함수 호출 이전에 호출해야 하지만
  // loadSettings() 함수 호출 이후에만 호출해야 한다.
  void init() { ... }

  // 사용자가 선택한 UI의 색상을 반환한다.
  // 선택된 색상이 없거나, 설정이 로드되지 않았거나, 초기화되지 않은 상태면
  // 널을 반환한다.
  Color? getUiColor() { ... }  / * 널 반환값은 두 가지 중 하나를 의미하는데,
                                 * 사용자가 색상을 선택하지 않았거나 클래스가 완전히 초기화되지 못했음이다.
                                 * /
```

위 예제 코드의 계약을 자세히 살펴보자.
- 명확한 부분
  - 클래스의 이름은 UserSettings이다. 따라서 분명히 사용자 설정을 포함하고 있을 것이다.
  - getUiColor()는 사용자가 선택한 UI 색상을 반환할 것이라는 점이 거의 확실하다. 색상 또는 널을 반환한다.
    주석문을 읽지 않으면 널이 무엇을 의미하는지 모호하지만 사용자가 색상을 선택하지 않았다는 것을 의미하는 것으로 생각한다면 타당한 추측일 것이다.
  - loadSettings()은 파일 객체를 매개변수로 받고 불리언값을 반환한다. 주석문을 읽지 않고도 이 반환값이 참이면 성공을 나타내고, 거짓이면 실패를 나타낸다는 것을 알 수 있다.
- 세부 조항
  - 이 클래스는 매우 구체적인 순서로 함수 호출이 이뤄져야 한다. 첫 번째 loadSettings()을 호출해야 한다.
    이 함수가 성공적으로 수행된 경우에 init()이 호출되어야 하고, 그제야 이 클래스를 사용할 수 있다.
  - loadSettings()이 거짓(false)을 반환하면, 이 클래스의 다른 함수들을 호출하면 안 된다.
  - getUiColor()이 널값을 반환하면 이것은 사용자가 색상을 선택하지 않았거나 클래스가 아직 설정되지 않았음을 의미한다.

이 클래스의 계약은 바람직하지 않다. 이 클래스를 사용하는 개발자가 모든 세부 조항, 즉 주석문을 주의 깊게 읽지 않으면 이 클래스를 올바르게 설정하지 못할 가능성이 크다.
클래스가 제대로 설정되지 못한 경우 그 사실이 분명하지 않을 수도 있다. 왜냐하면 getUiColor()가 널값의 의미를 이중으로 가지고 있기 때문이다(주석문을 읽지 않는 한 이것을 알 수 없다).
<br/>
<br/>
이것이 어떻게 문제가 될 수 있는지 논의하기 위해 예제 3.2의 코드를 살펴보자.
setUiColor() 함수를 호출하기 전에 userSetting이 올바르게 설정되지 않더라도 프로그램은 계속 동작할 것이고, 모호하더라도 무언가를 수행하지만 여기에는 분명히 버그가 발생한다.
즉, 사용자가 선택한 UI 색상이 존재하더라도 이것이 무시된다.

#### [예제 3.2] 잠재적인 버그가 있는 코드
```java
void setUiColor(UserSettings userSettings) {
  Color? chosenColor = userSettings.getUiColor();
  if (chosenColor == null) {
    ui.setColor(DEFAULT_UI_COLOR);  / * getUiColor()가 널값을 반환하면 기본 색상을 사용한다.
    return;                           * 이것은 사용자가 색상을 선택하지 않았거나
  }                                   * UserSettings 클래스가 유효하지 못한 상태에 있을 때 일어날 수 있다.
  ui.setColor(chosenColor);           * /
}
```
다음 그림은 이 코드에서 설정이 잘못 이루어져서 잠재적으로 버그를 발생시킬 수 있는 모든 방법을 열거한다.<br/>
현재 이러한 오용을 완화할 수 있는 방법은 세부 조항밖에 없는데, 이미 살펴본 바와 같이 세부 조항은 일반적으로 코드 계약을 전달하기 위해 신뢰할 만한 방법이 아니다.
현재와 같은 코드는 버그가 스며들 가능성이 크다.
<br/>
<br/>
<img src="https://github.com/silxbro/clean-code/assets/142463332/586ed950-4c08-460c-9b69-b14cea02f809" width="500" height="400"/><br/>
- 코드를 오용할 수 있는 방법이 많을수록 실제로 오용되고 소프트웨어에 버그가 있을 가능성이 크다.

### [세부 조항을 제거하는 방법]
다른 개발자가 코드를 올바르게 사용하기 위해 세부 조항에 의존하기보다 잘못된 일을 하는 것을 **처음부터 불가능하게** 만드는 것이 좋다.
코드 계약의 세부 조항에 있는 어떤 항목에 대해 발생 자체가 불가능하도록 (또는 적어도 실수할 가능성이 없도록 하는) 명백한 항목으로 바꾸는 것이 가능한 경우가 있다.
코드가 **어떤 상태에 들어갈 수 있는지 혹은 입력이나 반환으로 어떤 데이터 유형을 취할 수 있는지** 신중하게 생각해보면 이렇게 변경하는 것이 가능할 때가 있다.
코드가 오용되거나 잘못 설정되면 컴파일조차 되지 않도록 하는 것이 목표다.

UserSettings 클래스는 **정적 팩토리(factory) 함수**를 사용해 초기화가 완전히 이루어진 인스턴스를 얻는 것만 가능하도록 수정할 수 있다.
달리 말하면, UserSettings 인스턴스를 사용하는 모든 코드는 초기화가 이미 완전히 실행된 인스턴스를 갖는다.

다음 예제 코드(예제 3.3)에세 UserSettings 클래스는 다음과 같은 방식으로 변경된다.
- create()라는 정적 팩토리 함수가 추가된다. 이 함수는 설정값 로딩 및 초기화 작업을 처리하고 유효한 상태에 있는 클래스의 인스턴스만 반환한다.
- 이 클래스의 외부에서 create() 함수를 사용하도록 강제하기 위해 생성자는 프라이빗으로 설정된다.
- 클래스 외부에서 loadSettings() 및 init() 함수를 호출하지 못하도록 프라이빗으로 변경되는데, 그렇지 않으면 클래스의 인스턴스를 잘못된 상태로 만들 수 있다.
- 클래스의 인스턴스가 유효한 상태에 있는 것이 보장되기 때문에 getUiColor() 함수가 널값을 반환하면 이는 사용자가 색상을 제공하지 않았다는 것을 의미한다.

#### [예제 3.3] 세부 조항이 거의 없는 코드
```java
class UserSettings {

  private UserSettings() { ... }  / * 생성자는 프라이빗이고 이로 인해 이 코드를 사용하는 다른 개발자는
                                    * 생성자 대신 create()를 사용할 수밖에 없다.
                                    * /
  static UserSettings? create(File location) {  / * UserSettings 클래스의 인스턴스를 만들기 위한 유일한 방법은
    UserSettings settings = new UserSettings();   * 이 함수를 호출하는 것이다.
    if (!settings.loadSettings(location)) {       * /
      return null;    / * 설정값을 로딩하는 것이 실패하면 널값을 반환한다.
    }                   * 이렇게 함으로써 누구도 유효하지 않은 상태의 인스턴스를 가질 수 없다.
    settings.init();    * /
    return settings;
  }

// 클래스의 상태를 변경하는 함수는 다 프라이빗이다.

  private Boolean loadSettings(File location) { ... }

  private void init() { ... }

// 사용자가 선택한 UI 색상을 반환한다. 색상을 선택하지 않은 경우에는 널을 반환한다.
  Color? getUiColor() { ... }  // 반환되는 값이 널이면 사용자가 색상을 선택하지 않았다는 의미만을 갖는다
}
```
이렇게 변경하면 UserSettings 클래스의 계약에서 거의 모든 숨겨진 세부 조항을 성공적으로 제거하고, 잘못된 상태의 인스턴스를 만드는 것이 불가능해진다.
숨겨진 세부 조항 중 남은 것은 getUiColor()이 널값을 반환할 때 무엇을 의미하는지 설명하는 것이지만, 이조차도 필요하지 않다.
왜냐하면 대부분의 사용자는 아마도 널값의 의미를 추측할 수 있고, 더 이상 클래스가 잘못된 상태에 있다는 것을 나타내지 않기 때문이다.

다음 그림은 이렇게 변경된 클래스를 어떻게 사용할 수 있는지, 특히 잘못된 상태의 클래스 인스턴스를 생성하는 것이 어떻게 불가능한지를 보여준다.
이런 방식에 이미 어느 정도 익숙한 독자라면, 여기에서 사용된 기법이 어떤 **상태**(state)나 **가변성**(mutability)이 클래스 외부로 노출되는 것을 없앤다는 점을 알아챘을 것이다.

#### [상태와 가변성]
코드 품질을 향상하기 위한 많은 방법은 상태와 가변성, 이 두 가지를 최소화하는 것과 관련이 있다.

객체의 상태는 객체가 담고 있는 어떤 값이나 데이터를 말한다.
객체를 만든 후 이러한 객체의 상태를 수정할 수 있으면 이 객체는 **가변적**(mutable)이라 한다.
반대로 객체를 생성한 후에 상태를 변경할 수 없다면, 이 객체는 **불변적**(immutable)이라고 한다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/9198edd1-b3f9-47d8-ab2c-dffabd859029" width="450" height="280"/><br/>
- 코드를 오용하는 것이 불가능하면 다른 개발자들이 그 코드를 사용할 때 버그가 침투할 가능성이 훨씬 낮아진다.

UserSettings 클래스가 여전히 완벽하지 않다는 점을 언급할 필요가 있다. 예를 들어 설정을 로드하는 것이 실패할 경우 널값을 반환하면 코드를 디버깅할 수 없다.
실패한 이유에 대한 오류 정보가 있으면 유용하다. (다음 장에서는 오류를 처리하는 방법을 살펴보고 널값을 반환하는 대신 사용할 수 있는 다양한 대안을 살펴본다.)

이 절의 예제 코드는 세부 조항으로 인해 오용하기 쉽고, 예측을 벗어나는 코드 작성이 가능하다는 것을 보여주기 위한 하나의 예에 불과하다.
코드에 숨겨진 세부 조항이 많을수록 오류가 손쉽게 발생할 수 있는 방법이 많다.
