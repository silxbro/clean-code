# 함수 호출도 가독성이 있어야 한다
<br/>

어떤 함수의 이름이 잘 명명되면 그 함수가 무슨 일을 하는지 분명하지만 이름이 잘 지어졌더라도
함수의 인수가 무엇을 위한 것이고, 무슨 역할을 하는지 명확하지 않다면 함수 호출 자체가 이해되지 않을 수 있다.

#### [많은 함수 인수]
함수 호출은 인수의 개수가 늘어나면 이해하기 힘들어진다. 함수나 생성자가 많은 수의 매개변수를 가지고 있으면 이것은 보다 **근본적인 문제**를 나타내는 것일 수 있다.
- 예를 들어 추상화 계층을 적절하게 정의하지 않았거나 코드가 충분히 모듈화되지 않았음을 의미할 수 있다. (추상화 계층: 2장, 모듈화: 8장)
<br/>

## 1. 매개변수는 이해하기 어려울 수 있다
다음은 메시지를 보내는 함수를 호출하는 코드다. 함수의 인수가 무엇을 나타내는지 분명하지 않다.
"hello"는 아마도 메시지일 것이라고 추측할 수 있지만, 1이나 true는 무엇을 의미하는지 알기 어렵다.
```java
sendMessage("hello", 1, true);
```
sendMessage() 에서 1과 true가 무엇을 의미하는지 알려면 함수 정의를 살펴봐야 한다.
함수 정의를 확인하면, 1은 메시지 우선순위를 나타내고 true는 메시지의 전송이 실패할 경우 다시 전송을 시도한다는 의미라는 것을 알 수 있다.
```java
void sendMessage(String message, Int priority, Boolean allowRetry) {
  ...
}
```
함수 호출 시 각 인수의 값이 무엇을 의미하는지 알려면 함수 정의를 확인해봐야 한다.
함수 정의가 완전히 다른 파일에 있거나, 수백 줄 떨어져 있다면 이것은 상당히 힘든 작업일 수 있다.
주어진 코드가 무엇을 하는지 알아내기 위해 다른 파일이나 많은 줄을 확인해야 한다면, 그 코드는 가독성이 떨어진다.
이를 개선할 수 있는 몇 가지 방법이 있으며, 다음에 나올 하위 절에서 이 해결책 중 몇 가지를 살펴본다.

## 2. 해결책: 명명된 매개변수 사용
명명된 매개변수는 점점 더 많은 언어, 특히 최근에 나온 언어에서 지원되고 있다.
함수 호출에서 명명된 인수를 사용할 때, 인수 목록 내의 위치가 아닌 이름으로 일치하는 매개변수를 찾는다.
명명된 인수를 사용한다면, 함수 정의를 확인하지 않고도 sendMessage() 함수에 대한 호출은 쉽게 이해할 수 있다.
```java
sendMessage(message: "hello", priority: 1, allowRetry: true);
```
안타깝지만 모든 언어가 명명된 매개변수를 지원하는 것은 아니므로, 이 방법은 이 기능을 지원하는 프로그래밍 언어에만 해당된다.
그럼에도 불구하고 때때로 명명된 매개변수인 것처럼 만들 수 있는 방법이 있다.
이것은 **객체 구조 분해**(object destructuring)를 사용하는 타입스크립트(TypeScript) 및 다른 형태의 자바스크립트에서 흔히 볼 수 있다.
예제 5.18 코드는 타입스크립트로 sendMessage() 함수를 작성할 때 객체 구조 분해를 어떻게 사용할 수 있는지 보여준다.
함수는 SendMessageParams 유형의 단일 객체를 매개변수로 허용하지만 이 객체는 즉시 매개변수의 속성으로 구조 분해되고 함수 내에서 이 속성을 직접 읽을 수 있다.

#### [예제 5.18] 타입스크립트에서 객체 구조 분해
```java
interface SendMessageParams {  // 함수의 매개변수의 유형을 정의하는 인터페이스
  message: string,
  priority: number,
  allowRetry: boolean,
}
async function sendMessage(
    {message, priority, allowRetry} : sendMessageParams) {  // 함수의 매개변수는 즉시 각 속성으로 분해된다.
  const outcome = await XhrWrapper.send(
      END_POINT, message, priority);  // 분해된 객체의 속성은 직접 사용할 수 있다.
  if (outcome.failed() && allowRetry) {
    ...
  }
}
```
다음 코드는 sendMessage() 함수 호출이 어떻게 이루어지는지 보여준다. 함수는 객체와 함께 호출되는데, 이것은 각 값이 속성 이름과 관련되어 있음을 의미한다.
이렇게 하면 명명된 매개변수와 거의 같은 기능을 수행한다.
```java
sendMessage({
// 인수의 이름이 각 값과 연관되어 있다.
  message: 'hello',
  priority: 1,
  allowRetry: true,
});
```
객체 구조 분해를 이용해 명명된 매개변수와 같은 효과를 얻는 것은 (다른 형태의 자바스크립트를 포함해서) 타입스크립트에서 비교적 흔하기 떄문에,
약간의 번거로움이 있지만 이 기법은 다른 개발자들에게 익숙할 것이다. 그 밖의 언어에서도 명명된 인수와 비슷한 효과를 얻을 수 있는 방법이 있지만,
다른 개발자가 익숙하지 않은 기능을 사용하면 문제를 해결하기보다는 더 많은 문제를 일으킬 수도 있음을 유의해야 한다.

## 3. 해결책: 서술적 유형 사용
사용하는 프로그래밍 언어의 명명된 매개변수 지원 여부와 상관없이 함수를 정의할 때 좀 더 서술적인 유형을 사용하는 것이 바람직하다.
이번 절의 시작 부분에서 살펴본 시나리오에서 sendMessage() 함수의 작성자는 우선순위를 나타내기 위해 정수를 사용했고, 재시도 허용 여부를 나타내기 위해 불리언값을 사용했다.
```java
void sendMessage(String message, int priority, Boolean allowRetry) {
  ...
}
```
정수와 불리언은 상황에 따라 어떤 종류의 값이라도 의미할 수 있기 때문에 그 자체로는 서술적이지 않다.
다른 방안으로는 sendMessage() 함수를 작성할 때 **특정 유형**을 만들어 그 매개변수들이 나타내는 바를 설명하는 것이다. 예제 5.19는 이를 위한 두 가지 방법을 보여준다.
- **클래스**: 메시지의 우선순위를 클래스로 표현한다.
- **열거형**: 재시도 정책은 불리언 대신 두 가지 옵션이 있는 열거형을 사용한다.

#### [예제 5.19] 함수 호출에서의 서술적 유형
```java
class MessagePriority {
  ...
  MessagePriority(Int priority) { ... }
  ...
}

enum RetryPolicy {
  ALLOW_RETRY,
  DISALLOW_RETRY
}

void sendMessage(
    String message,
    MessagePriority priority,
    RetryPolicy retryPolicy) {
  ...
}
```
아래 코드에서 볼 수 있듯이 이 함수에 대한 호출은 함수 정의를 알지 못해도 이해하기 쉽다.
```java
sendMessage("hello", new MessagePriority(1), RetryPolicy.ALLOW_RETRY);
```

### 4. 때로는 훌륭한 해결책이 없다
함수를 호출하는 라인의 가독성을 높여주는 특별한 방법이 없을 때가 있다. 이것을 설명하기 위해 2차원 경계 상자를 나타내기 위한 클래스가 필요하다고 가정해보자.
예제 5.20 코드와 같은 BoundingBox 클래스를 작성할 수 있을 것이다. 이 클래스의 생성자는 상자의 모서리 위치를 나타내는 4개의 정숫값을 매개변수로 받는다.

#### [예제 5.20] 경계 박스 클래스
```java
class BoundingBox {
  ...
  BoundingBox(Int top, Int right, Int bottom, Int left) {
    ...
  }
}
```
사용하는 프로그래밍 언어가 명명된 매개변수를 지원하지 않는다면, 이 생성자에 대한 호출은 각 숫자가 무엇을 나타내는지에 대한 힌트 없이 일련의 숫자만 보여주기 때문에
이해하기가 쉽지 않다. 모든 인수는 정수이기 때문에 개발자가 인수의 순서를 혼동하고, 완전히 엉망인 순서로 호출을 해도 여전히 컴파일이 잘되는 코드를 작성하기가 매우 쉽다.
다음 코드는 BoudingBox 생성자를 호출하는 예를 보여준다.
```java
BoundingBox box = new BoundingBox(10, 50, 20, 5);
```
이 경우는 특별히 만족스러운 해결책이 없으며, 여기서 최선의 방법은 생성자를 호출할 때 각각의 인수가 무엇인지 설명하기 위해 **인라인 주석문**을 사용하는 것이다.
이렇게 한다면 생성자 호출은 아래와 같을 것이다.
```java
BoundingBox box = new BoundingBox(
  /* top= */10,
  /* right= */50,
  /* bottom= */20,
  /* left= */5);
```
인라인 주석문은 분명히 생섣자 호출 코드의 가독성을 높인다.
하지만 이렇게 코드를 작성할 때 실수를 하지 않아야 하고, 이런 주석문을 최신 상태로 계속 유지해야 하므로 그다지 만족스러운 해결책은 아니다.
한편으로는 이러한 인라인 주석문을 사용하지 말아야 한다는 주장도 있다. 왜냐하면 주석문이 더 이상 맞지 않을 위험이 있기 때문이다.
최신 내용으로 바뀌지 않은 주석문은 주석문이 아예 없는 것보다 더 나 나쁘다.

세터(setter) 함수를 추가하거나 (7장에서 살펴볼) 빌더 패턴과 같은 것을 사용하는 것이 대안이 될 수 있지만,
두 방법 모두 값이 누락된 채 인스턴스가 만들어질 수 있기 때문에 코드가 쉽게 오용될 수 있는 단점이 있다.
코드가 올바른지 확인하기 위해 (컴파일 타임 확인 대신) 런타임 확인을 통해 이런 오용을 방지해야 할 것이다.

## 5. IDE는 어떤가?
어떤 통합 개발 환경(integrated development environment, IDE)은 백그라운드 작업을 통해 함수 정의를 미리 찾아놓는다.
그다음 함수의 매개변수 이름을 표시해준다. 다음 그림은 이 기능을 보여준다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/84e8dcfc-6896-43e9-a40c-ddffd908f585" width="400" height="100"/><br/>
- IDE에 따라 함수 호출을 보다 쉽게 하기 위해 함수의 매개변수를 보여주기도 한다.

코드를 편집할 때 이 방법이 대단히 유용하지만 코드의 가독성을 위해 이 기능에 의존하지 않는 것이 좋다.
모든 개발자가 이런 기능을 제공하는 IDE를 사용하고 있는 것도 아니고, 이런 기능이 아예 없는 도구, 예를 들어 코드베이스 탐색 도구, 병합 도구, 코드 검토 도구와 같은 도구는
IDE 도움 없이 코드 그 자체만 봐야 하기 때문이다.
