# 예상치 못한 부수 효과를 피하라
<br/>

**부수 효과**(side effect)는 어떤 함수의 호출이 함수 외부에 초래한 상태 변화를 의미한다. **함수가 반환하는 값 외에 다른 효과가 있다면** 이는 부수 효과가 있는 것이다.
일반적인 부수 효과 유형은 다음과 같다.
- 사용자에게 출력 표시
- 파일이나 데이터베이스에 무언가를 저장
- 다른 시스템을 호출하여 네트워크 트래픽 발생
- 캐시 업데이트 혹은 무효화

부수 효과는 소프트웨어 작성 시 불가피한 부분이다. 부수 효과가 없는 소프트웨어는 무의미할 것이다.
어느 시점에서 사용자, 데이터베이스, 다른 시스템 등에 무언가를 출력해야 한다. 이것은 적어도 코드의 일부에서는 부수 효과가 있어야 한다는 것을 의미한다.
부수 효과가 예상되고 코드를 호출한 쪽에서 그것을 원한다면 괜찮지만, 부수 효과가 예상되지 않을 경우 놀라움을 유발하고 버그로 이어질 수 있다.

예상치 못한 부수 효과를 일으키는 것을 피하는 좋은 방법 중 하나는 애초에 부수 효과가 일어나지 않도록 하는 것이다. 이번 절과 6.4절의 예를 통해 이에 관해 살펴본다.
그러나 클래스를 불가변(immutable)으로 만드는 것 또한 부수 효과의 가능성을 최소화하는 좋은 방법이며, 이에 대해서는 7장에서 다룬다.
부수 효과가 원하는 기능의 일부이거나 피할 수 없는 경우에는 호출하는 쪽에서 이에 대해 확실하게 인지하도록 하는 것이 중요하다.
<br/>
<br/>
## 1. 분명하고 의도적인 부수 효과는 괜찮다
방금 언급한 바와 같이 부수 효과가 코드의 어떤 부분에서 필요할 때가 있다. 예제 코드 6.18은 사용자 디스플레이를 관리하기 위한 클래스를 보여준다.
displayErrorMessage() 함수는 한가지 부수 효과를 가지고 있는데, 사용자에게 표시되는 캔버스를 업데이트하는 것이다.
그러나 클래스를 UserDisplay라고 명명하고 함수를 displayErrorMessage()라고 하는 경우 이러한 부수 효과가 발생할 것이라는 점이 명백하고 예상을 벗어나는 동작은 없다.

#### [예제 6.18] 예상되는 부수 효과
```java
class UserDisplay {
  private final Canvas canvas;
  ...

  void displayErrorMessage(String message) {
    canvas.drawText(message, Color.RED);  // 부수 효과: 캔버스가 업데이트된다.
  }
}
```
displayErrorMessage() 함수는 분명하고 의도적으로 부수 효과를 일으키는 예이다. 오류 메시지로 캔버스를 업데이트하는 것은 호출하는 쪽에서 원하고 예상하는 바이다.
반면에, 호출하는 쪽에서 반드시 예상하거나 원하지 않는 부수 효과는 문제가 될 수 있다. 다음 하위 절에서 이에 대해 살펴본다.

## 2. 예기치 않은 부수 효과는 문제가 될 수 있다
함수의 목적이 값을 가져오거나 읽기 위한 경우, 다른 개발자는 일반적으로 함수 호출이 부수 효과를 일으키지 않는다고 가정한다.
예제 코드 6.19는 사용자 디스플레이의 특정 픽셀에서 색상을 가져오는 함수를 보여준다. 이 함수는 상대적으로 쉽고 부수 효과도 없는 것처럼 보이지만 불행히도 그렇지 않다.
픽셀 색상을 읽기 전에 캔버스를 다시 그리는 동작을 수행한다. 이것은 부수 효과이며, getPixel() 기능의 구현에 익숙하지 않은 사람이라면 예상을 벗어나는 결과가 될 것이다.

#### [예제 6.19] 예상치 못한 부수 효과
```java
class UserDisplay {
  private final Canvas canvas;
  ...

  Color getPixel(Int x, Int y) {
    canvas.redraw();  // 다시 그리기 이벤트를 발생하는 것은 부수 효과다.
    PixelData data = canvas.getPixel(x, y);
    return new Color(
      data.getRead(),
      data.getGreen(),
      data.getBlue());
  }
}
```
이와 같이 예상치 못한 부수 효과가 문제의 소지가 될 수 있는 몇 가지 경우가 있다. 다음 몇 개의 하위 절에서 이 중 일부를 살펴볼 것이다.

### 부수 효과는 비용이 많이 들 수 있다
canvas.redraw()를 호출하는 작업은 잠재적으로 비용이 상당히 많이 들 수 있으며 사용자의 디스플레이가 깜빡거릴 수도 있다.
getPixel()을 호출하는 개발자는 이 작업이 비용이 많이 들거나 사용자에게 보이는 문제를 일으킬 것이라고 예상하지 않는다. getPixel() 함수의 이름이 이러한 것을 나타내고 있지 않다.
하지만 이 함수를 실행할 때 시간이 오래 걸린다거나 깜빡임이 일어난다면, 대부분의 사용자는 그것을 끔찍한 버그로 해석할 수 있는 바람직하지 않은 기능이다.

사용자가 디스플레이의 스크린숏을 찍을 수 있도록 하는 기능을 애플리케이션에 추가한다고 가정해보자. 예제 6.20 코드에는 이 기능이 어떻게 구현될 수 있는지 나와 있다.
captureScreenshot() 함수는 getPixel() 함수를 호출하여 픽셀을 하나씩 읽는다. 이로 인해 스크린숏의 모든 픽셀에 대해 canvers.redraw()가 호출된다.
하나의 다시 그리기 이벤트가 10밀리초가 걸리고 사용자 디스플레이가 400⨉700 픽셀(즉, 총 28만 픽셀)이라고 가정해보자.
스크린숏 캡처를 하나 하려면 47분간 애플리케이션은 멈추고 깜빡거릴 것이다.
대부분의 사용자는 이것이 시스템이 멈춘 것으로 알고 시스템을 다시 시작할 것이고, 저장되지 않은 작업은 잃어버릴 것이다.

#### [예제 6.20] 스크린숏 캡처
```java
class UserDisplay {
  private final Canvas canvas;
  ...
  Color getPixel(Int x, Int y) { ... }   // 부수 효과로 인해 실행하는 데 10밀리초가 걸린다.
  ...

  Image captureScreenshot() {
    Image image = new Image(
        canvas.getWidth(), canvas.getHeight());
    for (Int x = 0; x < image.getWidth(); ++x) {
      for (Int y = 0; y < image.getHeight(); ++y) {
        image.setPixel(x, y, getPixel(x, y));  // getPixel()이 여러 번 호출된다.
      }
    }
    return image;
  }
}
```

### 호출한 쪽의 가정을 깨뜨리기
캔버스를 다시 그리는 것의 비용이 적게 들더라도 captureScreenshot()이라는 이름을 보면 부수 효과를 일으킬 것 같지 않기 때문에, 이 함수를 호출하는 대부분의 개발자는
부수 효과가 없을 것이라고 가정한다. 이 가정은 잘못됐기 때문에 버그를 일으킬 가능성이 있다.

예제 6.21 코드는 편집된 스크린숏을 캡처하는 함수를 보여준다. 이 함수는 캔버스에서 사용자의 개인 정보가 들어 있는 영역을 삭제한 후에 captureScreenshot()을 호출한다.
이 함수는 사용자가 피드백을 주거나 버그를 보고할 때마다 익명화된 스크린숏을 캡처하는 데 사용된다.
캔버스 영역을 삭제하면 canvas.redraw()를 다시 호출하기 전까지는 해당 픽셀이 지워진다. 즉, canvas.redraw()가 호출되면 임시로 지운 것은 다시 보여진다.

captureRedactedScreenshot() 함수의 작성자는 captureScreenshot()에서 canvas.redraw()를 호출하지 않을 것으로 가정한다.
하지만 captureScreenshot()은 getPixel()을 호출하고, getPixel()은 canvas.redraw()를 호출하기 때문에 이 가정은 잘못된 것이다.
이는 편집 기능이 전혀 동작하지 않고, 개인 정보가 피드백 보고에 포함되어 전송됨을 의미한다. 이것은 심각한 사용자 개인 정보 침해이며 중대한 버그다.

#### [예제 6.21] 편집된 스크린숏 캡처
```java
class UserDisplay {
  private final Canvas canvas;
  ...

  Color getPixel(Int x, Int y) { ... }  // canvas.redraw()를 호출함으로써 부수 효과가 발생한다.

  Image captureScreenshot() { ... }  // getPixel()을 호출함으로써 간접적으로 부수 효과가 발생한다.

  List<Box> getPrivacySensitiveAreas() { ... }  // 개인 정보를 담고 있는 캔버스 영역을 반환한다.

  Image captureRedactedScreenshot() {
    for (Box area int getPrivacySensitiveAreas()) {
      canvas.delete(  // 개인 정보를 담고 있는 픽셀을 제거한다.
          area.getX(), area.getY(),
          area.getWidth(), area.getHeight()
    }
    Image screenshot = captureScreenshot();  // 스크린숏을 캡처한다.
    canvas.redraw();  // 의도적인 실행: 이 함수의 작성자는 canvas.redraw()가 여기에서만 호출된다고 생각한다.
    return screenshot;
  }
}
```

### 다중 스레드 코드의 버그
프로그램이 상대적으로 독립적인 여러 작업을 수행할 필요가 있는 경우, 이를 달성하는 일반적인 방법은 각 작업을 자체 **스레드**(thread)에서 실행하는 것이다.
그다음 컴퓨터는 스레드를 차례대로 **선점**(preempting)하고, **다시 시작**(resuming)함으로써 작업 사이를 빠르게 전환한다. 이것을 **멀티스레딩**(multithreading)이라고 한다.
서로 다른 스레드가 종종 동일한 데이터에 액세스할 수 있기 때문에 한 스레드로 인한 부수 효과는 때때로 다른 스레드에 문제를 일으킬 수 있다.

스크린숏과 관련되어 살펴본 응용 프로그램에서 사용자가 자신의 화면을 친구와 라이브로 공유할 수 있는 기능이 있다고 가정해보자.
이 기능은 스크린숏을 주기적으로 캡처하여 친구에게 보내는 다른 스레드를 사용하여 구현할 수 있다.
두 개 이상의 스레드가 captureScreenshot()을 동시에 호출하는 경우, 한 스레드가 캔버스를 다시 그릴 수 있고 다른 스레드가 읽으려고 할 때 스크린숏이 끊어질 수 있다.
다음 그림은 두 개의 개별 스레드에서 getPixel()을 호출할 때 이들이 어떻게 상호작용할 수 있는지를 보여준다.

<img src="https://github.com/silxbro/clean-code/assets/142463332/d8ff7ffa-3da3-44b0-b878-12c9456e3ace" width="550" height="450"/><br/>
- 부수 효과가 있는 코드가 다중 스레드 환경에서 실행될 때 작성자가 로크(lock)와 같은 스레드 안전을 위한 조치를 취하지 않는 경우 문제가 될 수 있다.

함수에 대한 개별 호출에서 멀티스레딩 문제가 발생할 확률은 일반적으로 매우 낮다. 그러나 함수를 수천 번(혹은 수백만 번) 호출할 경우 발생 확률이 누적되어 상당히 높아진다.
다중 스레드 문제와 관련된 버그는 디버깅과 테스트가 어렵기로 악명높다.

다른 개발자가 captureScreenshot()이나 getPixel()이라는 함수를 접하면 둘 중 어느 것도 다른 스레드에서 실행 중인 코드의 동작에 악영향을 끼치는 부수 효과가 일어나리고라는
예상하지 않을 것이다. 다중 스레드 환경에서 제대로 동작하지 않는 코드를 작성하면 예상과 다르게 작동하는 상황을 마주할 수 있고 이런 상황은 바람직하지 않다.
이 경우 디버깅과 문제 해결에 많은 시간을 낭비할 수 있다. 부수 효과를 피하거나 그렇지 않으면 그것이 발생할 것이라는 사실을 명백하게 하는 것이 훨씬 낫다.

## 3. 해결책: 부수 효과를 피하거나 그 사실을 분명하게 하라
픽셀을 읽기 전에 canvas.redraw()를 호출하는 것이 정말로 필요한지를 가장 먼저 질문해야 한다.
그 함수를 호출하는 것이 어쩌면 지나치게 신중한 코드일 수 있고, 적절성 여부를 깊이 따져보지 않은 결과일 수도 있다.
예측 가능한 코드를 작성하기 위한 가장 좋은 방법은 애초에 부수 효과를 일으키지 않는 것이다.
Canvas.redraw()를 호출할 필요가 없으면 호출하지 말아야 하며, 그렇게 하면 문제 자체가 없어진다.

픽셀을 읽기 전에 canvas.redraw()를 호출해야 하는 경우, getPixel() 함수의 이름을 변경하여 이 부수 효과가 발생할 것이라는 점을 분명히 나타내야 한다.
더 좋은 이름은 redrawAndGetPixel()과 같은 것으로 이 이름을 통해 이 함수가 다시 그리기 이벤트를 유발하는 부수 효과가 발생할 것이라는 점을 분명히 하는 것이다.
다음 예제는 이에 대한 코드를 보여준다.

#### [예제 6.22] 더 많은 정보를 제공하는 이름
```java
class UserDisplay {
  private final Canvas canvas;
  ...

  Color redrawAndGetPixel(Int x, Int y) {  // 함수의 이름을 통해 부수 효과에 대해 분명하게 알 수 있다.
    canvas.redraw();
    PixelData data = canvas.getPixel(x, y);
    return new Color(
        data.getRed(),
        data.getGreen(),
        data.getBlue());
  }
}
```
이렇게 수정하는 것은 매우 간단하고, 좋은 이름이 얼마나 중요한지 잘 보여준다.
개발자가 redrawAndGetPixel() 함수를 호출할 때 이 함수는 부수 효과를 가지고 있으며 다시 그리기 이벤트를 발생할 것이라는 점을 알 수밖에 없다.
이 방법은 이전 하위 절에서 살펴본 세 가지 문제를 해결하는 데 크게 도움이 된다.
- 다시 그리기는 비용이 높기 때문에 captureScreenshot() 함수의 작성자는 redrawAndGetPixel()을 for 루프에서 수천 번 호출하는 것이 과연 필요한지 한 번 더 생각해볼 수 있다.
  이 경우 다시 그리기를 한 번만 수행한 다음 모든 픽셀을 한 번에 읽는 등의 방식으로 함수를 다르게 구현할 수 있다.
- captureScreenshot() 함수의 작성자가 부수 효과를 분명히 하기 위해 함수의 이름 역시 수정한다면 redrawAndCaptureScreenshot()로 변경할 수 있다.
  이렇게 변경된 함수의 이름으로 인해 다른 개발자는 다시 그리기 이벤트가 일어나지 않을 것이라고 잘못 가정하지 않게 된다.
- redrawAndCaptureScreenshot()이라는 함수를 사용하는 경우 화면 공유 기능을 구현하는 개발자는 다중 스레드 환경에서 이 함수를 호출할 때의 위험성을 즉시 인식할 수 있다.
  이 경우 스레드 안전을 위해 로크를 사용하는 등의 추가 작업을 해야 할 것이다.
  하지만 이렇게 추가로 작업하는 것이 이 사실을 알지 못한 채 예상을 벗어나는 동작과 나아가 오류를 일으키는 것보다 훨씬 낫다.
<br/>

정보를 얻는 함수는 일반적으로 부수 효과를 일으키지 않기 때문에 개발자의 자연스러운 정신 모델에서는 그러한 함수들이 부수 효과를 일으키지 않을 것이라고 가정한다.
따라서 어떤 함수가 부수 효과를 일으킨다면, 그 함수를 호출하는 쪽에서 이 사실에 대해 명백하게 알 수 있도록 하는 책임이 함수의 작성자에게 있다.
애초에 부수 효과를 일으키지 않는 것이 예측 가능한 코드를 위해 가장 좋은 방법이지만, 실제로 그렇게 하기 어려운 경우도 있다.
부수 효과를 피할 수 없을 때 적절하게 이름을 짓는 것은 그 사실을 명백하게 나타내는 매우 효과적인 방법이다.
